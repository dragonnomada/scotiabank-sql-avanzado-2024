<!DOCTYPE html>
        <html>
        <head>
            <meta charset="UTF-8">
            <title>Curso de SQL Avanzado - Sesi&oacute;n 1</title>
            <style>
/* From extension vscode.github */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

.vscode-dark img[src$=\#gh-light-mode-only],
.vscode-light img[src$=\#gh-dark-mode-only],
.vscode-high-contrast:not(.vscode-high-contrast-light) img[src$=\#gh-light-mode-only],
.vscode-high-contrast-light img[src$=\#gh-dark-mode-only] {
	display: none;
}

</style>
            
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/markdown.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/highlight.css">
<style>
            body {
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe WPC', 'Segoe UI', system-ui, 'Ubuntu', 'Droid Sans', sans-serif;
                font-size: 14px;
                line-height: 1.6;
            }
        </style>
        <style>
.task-list-item {
    list-style-type: none;
}

.task-list-item-checkbox {
    margin-left: -20px;
    vertical-align: middle;
    pointer-events: none;
}
</style>
<style>
:root {
  --color-note: #0969da;
  --color-tip: #1a7f37;
  --color-warning: #9a6700;
  --color-severe: #bc4c00;
  --color-caution: #d1242f;
  --color-important: #8250df;
}

</style>
<style>
@media (prefers-color-scheme: dark) {
  :root {
    --color-note: #2f81f7;
    --color-tip: #3fb950;
    --color-warning: #d29922;
    --color-severe: #db6d28;
    --color-caution: #f85149;
    --color-important: #a371f7;
  }
}

</style>
<style>
.markdown-alert {
  padding: 0.5rem 1rem;
  margin-bottom: 16px;
  color: inherit;
  border-left: .25em solid #888;
}

.markdown-alert>:first-child {
  margin-top: 0
}

.markdown-alert>:last-child {
  margin-bottom: 0
}

.markdown-alert .markdown-alert-title {
  display: flex;
  font-weight: 500;
  align-items: center;
  line-height: 1
}

.markdown-alert .markdown-alert-title .octicon {
  margin-right: 0.5rem;
  display: inline-block;
  overflow: visible !important;
  vertical-align: text-bottom;
  fill: currentColor;
}

.markdown-alert.markdown-alert-note {
  border-left-color: var(--color-note);
}

.markdown-alert.markdown-alert-note .markdown-alert-title {
  color: var(--color-note);
}

.markdown-alert.markdown-alert-important {
  border-left-color: var(--color-important);
}

.markdown-alert.markdown-alert-important .markdown-alert-title {
  color: var(--color-important);
}

.markdown-alert.markdown-alert-warning {
  border-left-color: var(--color-warning);
}

.markdown-alert.markdown-alert-warning .markdown-alert-title {
  color: var(--color-warning);
}

.markdown-alert.markdown-alert-tip {
  border-left-color: var(--color-tip);
}

.markdown-alert.markdown-alert-tip .markdown-alert-title {
  color: var(--color-tip);
}

.markdown-alert.markdown-alert-caution {
  border-left-color: var(--color-caution);
}

.markdown-alert.markdown-alert-caution .markdown-alert-title {
  color: var(--color-caution);
}

</style>
        
        </head>
        <body class="vscode-body vscode-light">
            <h1 id="curso-de-sql-avanzado---sesión-1">Curso de SQL Avanzado - Sesión 1</h1>
<img src="https://amei.mx/wp-content/uploads/2016/08/Scotiabank-logo.jpg" alt="Scotiabank Logo" height="60">
<img src="https://www.belatrix.com/wp-content/uploads/2023/08/belatrix-logosweb-1.png" alt="Belatrix Logo" height="60">
<p><strong><a href="https://www.scotiabank.com.mx">Scotiabank</a></strong> | <strong><a href="https://www.belatrix.com">Belatrix</a></strong></p>
<p>Instructor: <a href="alan@nomadacode.com">Alan Badillo Salas</a></p>
<hr>
<h2 id="contenido">Contenido</h2>
<pre><code>Módulo 1. Optimización de Consultas

1. Estrategias para mejorar el rendimiento
2. Índices avanzados y su impacto
3. Optimización de subconsultas y joins
</code></pre>
<h3 id="temas">Temas</h3>
<ol start="101">
<li>Repaso general a las consultas SQL</li>
<li>Tipos de datos principales</li>
<li>Subconsultas</li>
<li>Consultas anidadas</li>
<li>Uso de índices</li>
<li>Estrategias para mejorar el rendimiento</li>
</ol>
<h2 id="101-repaso-general-a-las-consultas-sql">101. Repaso general a las consultas SQL</h2>
<p>Este tema es esencial como punto de partida para cualquier curso avanzado de SQL, ya que establece una base sólida sobre la cual se pueden construir conceptos más complejos.</p>
<h3 id="sql-lenguaje-de-consulta-estructurada">SQL: Lenguaje de Consulta Estructurada</h3>
<p>SQL, que significa Lenguaje de Consulta Estructurada (Structured Query Language), es el lenguaje estándar utilizado para comunicarse con bases de datos. Permite a los usuarios realizar diversas tareas, como consultar datos, actualizar datos, insertar nuevos datos y borrar datos existentes, además de crear y modificar esquemas de base de datos y controlar el acceso a los datos.</p>
<h3 id="sintaxis-básica-de-sql">Sintaxis Básica de SQL</h3>
<p>La sintaxis básica de SQL implica la utilización de declaraciones o instrucciones para realizar operaciones en la base de datos. Algunas de las instrucciones más fundamentales incluyen:</p>
<ul>
<li><code>SELECT</code>: Se utiliza para seleccionar datos de una base de datos. Permite especificar exactamente qué datos deseas obtener.</li>
<li><code>INSERT INTO</code>: Se usa para insertar nuevos registros en una tabla.</li>
<li><code>UPDATE</code>: Permite modificar los datos existentes en una tabla.</li>
<li><code>DELETE</code>: Se utiliza para borrar registros de una tabla.</li>
<li><code>CREATE DATABASE</code>: Para crear una nueva base de datos.</li>
<li><code>CREATE TABLE</code>: Para crear una nueva tabla en la base de datos.</li>
<li><code>DROP TABLE</code>: Para eliminar una tabla existente.</li>
</ul>
<h3 id="estructura-de-una-consulta-sql">Estructura de una Consulta SQL</h3>
<p>Una consulta SQL típica que utiliza <code>SELECT</code> puede tener varias partes, incluyendo:</p>
<ul>
<li><code>SELECT</code>: Especifica las columnas que se van a retornar en el resultado.</li>
<li><code>FROM</code>: Indica la(s) tabla(s) de donde se van a extraer los datos.</li>
<li><code>WHERE</code>: Especifica las condiciones que deben cumplir los registros para ser seleccionados.</li>
<li><code>GROUP BY</code>: Agrupa filas que tienen los mismos valores en columnas especificadas.</li>
<li><code>HAVING</code>: Se utiliza después de <code>GROUP BY</code> para aplicar una condición a los grupos creados.</li>
<li><code>ORDER BY</code>: Ordena los registros resultantes según una o más columnas.</li>
</ul>
<h3 id="funciones-de-agregación">Funciones de Agregación</h3>
<p>Las funciones de agregación realizan un cálculo en un conjunto de valores y devuelven un valor único. Algunas de las funciones de agregación más comunes incluyen:</p>
<ul>
<li><code>COUNT()</code>: Devuelve el número de filas que coinciden con un criterio especificado.</li>
<li><code>SUM()</code>: Suma todos los valores de una columna.</li>
<li><code>AVG()</code>: Calcula el promedio de los valores en una columna.</li>
<li><code>MAX()</code>: Encuentra el valor máximo en una columna.</li>
<li><code>MIN()</code>: Encuentra el valor mínimo en una columna.</li>
</ul>
<h3 id="joins">Joins</h3>
<p>Los &quot;joins&quot; son utilizados para combinar filas de dos o más tablas, basados en una columna relacionada entre ellas. Los tipos de joins incluyen:</p>
<ul>
<li><strong>INNER JOIN</strong>: Retorna filas cuando hay al menos una coincidencia en ambas tablas.</li>
<li><strong>LEFT JOIN (o LEFT OUTER JOIN)</strong>: Retorna todas las filas de la tabla izquierda y las filas coincidentes de la tabla derecha.</li>
<li><strong>RIGHT JOIN (o RIGHT OUTER JOIN)</strong>: Retorna todas las filas de la tabla derecha y las filas coincidentes de la tabla izquierda.</li>
<li><strong>FULL JOIN (o FULL OUTER JOIN)</strong>: Combina los resultados de los LEFT JOIN y RIGHT JOIN.</li>
</ul>
<h2 id="102-tipos-de-datos-principales">102. Tipos de datos principales</h2>
<p>Entender los tipos de datos es fundamental para diseñar y trabajar con bases de datos de manera efectiva, ya que cada tipo de dato tiene un propósito específico y restricciones asociadas que ayudan a garantizar la integridad y el rendimiento óptimo de la base de datos.</p>
<h3 id="tipos-de-datos-en-sql">Tipos de Datos en SQL</h3>
<p>Los sistemas de gestión de bases de datos (DBMS, por sus siglas en inglés) soportan diversos tipos de datos para cubrir distintas necesidades de almacenamiento de información. Aunque los nombres y el soporte exacto pueden variar entre diferentes DBMS (como MySQL, PostgreSQL, SQL Server, Oracle, etc.), hay categorías comunes de tipos de datos en SQL:</p>
<h4 id="1-numéricos">1. Numéricos</h4>
<ul>
<li><strong>Enteros</strong>: Para números sin decimales. Pueden ser <code>INT</code> (o <code>INTEGER</code>), <code>SMALLINT</code>, <code>TINYINT</code>, y <code>BIGINT</code>, dependiendo del rango de valores que pueden almacenar.</li>
<li><strong>Decimales/Fijos</strong>: Para números con decimales donde se requiere precisión exacta, como <code>DECIMAL</code> o <code>NUMERIC</code>, donde puedes especificar la escala y precisión.</li>
<li><strong>Flotantes/Reales</strong>: Para números con decimales que no requieren una precisión fija, se utilizan <code>FLOAT</code>, <code>REAL</code>, o <code>DOUBLE</code>.</li>
</ul>
<h4 id="2-caracteres-y-cadenas-de-texto">2. Caracteres y Cadenas de Texto</h4>
<ul>
<li><strong>CHAR</strong>: Para cadenas de caracteres de longitud fija. Si el valor insertado es más corto que la longitud definida, el DBMS puede rellenar los espacios restantes con espacios en blanco.</li>
<li><strong>VARCHAR</strong>: Para cadenas de caracteres de longitud variable. Almacena cadenas de texto que pueden variar en longitud hasta un máximo definido.</li>
<li><strong>TEXT</strong>: Para textos largos como artículos, posts de blogs, etc. La capacidad exacta puede variar entre sistemas.</li>
</ul>
<h4 id="3-fecha-y-hora">3. Fecha y Hora</h4>
<ul>
<li><strong>DATE</strong>: Solo la fecha, sin la hora.</li>
<li><strong>TIME</strong>: Solo la hora, sin la fecha.</li>
<li><strong>DATETIME</strong>: La combinación de fecha y hora en un solo valor.</li>
<li><strong>TIMESTAMP</strong>: Similar a <code>DATETIME</code>, pero generalmente usado para registrar cuándo ocurren cambios en los registros.</li>
</ul>
<h4 id="4-lógicos">4. Lógicos</h4>
<ul>
<li><strong>BOOLEAN</strong>: Para almacenar valores verdadero o falso (<code>TRUE</code> o <code>FALSE</code>).</li>
</ul>
<h4 id="5-binarios">5. Binarios</h4>
<ul>
<li><strong>BINARY</strong> y <strong>VARBINARY</strong>: Similar a <code>CHAR</code> y <code>VARCHAR</code> pero para datos binarios (como imágenes o archivos).</li>
<li><strong>BLOB</strong>: Para almacenar datos binarios grandes, como imágenes, archivos de audio, etc.</li>
</ul>
<h3 id="elección-del-tipo-de-dato-adecuado">Elección del Tipo de Dato Adecuado</h3>
<p>La elección del tipo de dato adecuado es crucial por varias razones:</p>
<ul>
<li><strong>Eficiencia en almacenamiento y rendimiento</strong>: Usar el tipo de dato más ajustado al tipo de información que se desea almacenar minimiza el uso de almacenamiento y puede mejorar el rendimiento de las consultas.</li>
<li><strong>Integridad de datos</strong>: Asegura que los datos almacenados cumplan con ciertas condiciones y expectativas, evitando errores y problemas de calidad de datos.</li>
<li><strong>Facilidad de uso y mantenimiento</strong>: Facilita el desarrollo y mantenimiento de aplicaciones al proporcionar un esquema claro y comprensible.</li>
</ul>
<p>Al diseñar una base de datos, es importante considerar cuidadosamente el tipo de información que cada columna almacenará y seleccionar el tipo de dato más apropiado para esa información. Esto no solo afecta cómo se almacenan y recuperan los datos, sino también cómo se pueden manipular y presentar esos datos a través de las consultas SQL.</p>
<h3 id="ejemplo-de-creación-de-tabla-de-empleados">Ejemplo de Creación de Tabla de Empleados</h3>
<p>Este ejemplo refleja una variedad de tipos de datos para mostrar cómo se pueden aplicar en un contexto práctico.</p>
<pre><code class="language-sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> Empleados (
    ID_Empleado <span class="hljs-type">INT</span> <span class="hljs-keyword">PRIMARY</span> KEY,
    Nombre <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">100</span>),
    Apellido <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">100</span>),
    Email <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">255</span>),
    Salario <span class="hljs-type">DECIMAL</span>(<span class="hljs-number">10</span>, <span class="hljs-number">2</span>),
    Fecha_Nacimiento <span class="hljs-type">DATE</span>,
    Fecha_Contratacion DATETIME,
    Tiempo_Parcial <span class="hljs-type">BOOLEAN</span>,
    Foto_Perfil <span class="hljs-type">BLOB</span>,
    Numero_Telefonico <span class="hljs-type">CHAR</span>(<span class="hljs-number">10</span>),
    Departamento <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">50</span>),
    Posicion <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">50</span>),
    Hora_Entrada <span class="hljs-type">TIME</span>,
    Hora_Salida <span class="hljs-type">TIME</span>
);
</code></pre>
<h3 id="descripción-de-campos">Descripción de Campos</h3>
<ul>
<li><strong>ID_Empleado</strong>: Un número entero (<code>INT</code>) que actúa como la clave primaria de la tabla. Cada empleado tiene un ID único.</li>
<li><strong>Nombre y Apellido</strong>: Cadenas de caracteres (<code>VARCHAR</code>) que almacenan los nombres y apellidos de los empleados. Se usa <code>VARCHAR</code> para permitir variabilidad en la longitud de estos campos.</li>
<li><strong>Email</strong>: Un campo <code>VARCHAR</code> más largo para almacenar direcciones de correo electrónico, que pueden variar en longitud.</li>
<li><strong>Salario</strong>: Tipo <code>DECIMAL</code> utilizado para almacenar el salario de los empleados con precisión de dos decimales, adecuado para valores monetarios.</li>
<li><strong>Fecha_Nacimiento y Fecha_Contratacion</strong>: <code>DATE</code> se utiliza para la fecha de nacimiento porque solo necesitamos la fecha, mientras que <code>DATETIME</code> se utiliza para la fecha de contratación para incluir tanto la fecha como la hora.</li>
<li><strong>Tiempo_Parcial</strong>: Un campo <code>BOOLEAN</code> para indicar si el empleado trabaja a tiempo parcial (<code>TRUE</code>) o a tiempo completo (<code>FALSE</code>).</li>
<li><strong>Foto_Perfil</strong>: Tipo <code>BLOB</code> para almacenar imágenes de perfil de los empleados, que son datos binarios.</li>
<li><strong>Numero_Telefonico</strong>: <code>CHAR</code> se utiliza para números telefónicos porque tienen una longitud fija.</li>
<li><strong>Departamento y Posicion</strong>: Campos <code>VARCHAR</code> para describir el departamento y la posición del empleado dentro de la empresa, respectivamente.</li>
<li><strong>Hora_Entrada y Hora_Salida</strong>: <code>TIME</code> se usa para registrar la hora de entrada y salida del trabajo.</li>
</ul>
<p>Este ejemplo ilustra cómo se pueden usar diferentes tipos de datos en una tabla para representar de manera eficiente y efectiva la información sobre los empleados. Seleccionar el tipo de dato adecuado para cada campo es crucial para optimizar el almacenamiento, el rendimiento y la integridad de los datos.</p>
<h3 id="uso-de-fechas-con-timestamp">Uso de Fechas con Timestamp</h3>
<p>El manejo de fechas y horas en bases de datos puede volverse complejo, especialmente cuando se trata de zonas horarias y formatos de fecha específicos. SQL proporciona tipos de datos como <code>TIMESTAMP</code> y funciones como <code>TO_TIMESTAMP_TZ</code> para ayudar a manejar estos casos con mayor precisión y flexibilidad. Aquí explicaremos cómo se utiliza <code>TIMESTAMP</code> y cómo convertir un texto dado a un valor de fecha y hora con zona horaria usando <code>TO_TIMESTAMP_TZ</code>, aplicando un formato como ISO 8601.</p>
<h3 id="uso-de-timestamp">Uso de <code>TIMESTAMP</code></h3>
<p>El tipo de datos <code>TIMESTAMP</code> se utiliza para almacenar un punto específico en el tiempo, incluyendo la fecha y la hora. A diferencia del tipo <code>DATE</code> que solo incluye la fecha, <code>TIMESTAMP</code> puede almacenar la fecha junto con la hora, minutos, segundos y fracciones de segundo. Esto lo hace especialmente útil para registrar eventos o transacciones hasta con precisión de milisegundos, dependiendo del sistema de gestión de bases de datos (DBMS).</p>
<h4 id="ejemplo-de-timestamp">Ejemplo de <code>TIMESTAMP</code>:</h4>
<pre><code class="language-sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> eventos (
    id_evento <span class="hljs-type">INT</span> <span class="hljs-keyword">PRIMARY</span> KEY,
    nombre_evento <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">100</span>),
    momento <span class="hljs-type">TIMESTAMP</span>
);
</code></pre>
<p>En este ejemplo, la columna <code>momento</code> podría almacenar valores como <code>2024-04-07 20:30:00.123456</code>, lo que indica el año, mes, día, hora, minuto, segundo y milisegundos del evento.</p>
<h3 id="uso-de-to_timestamp_tz">Uso de <code>TO_TIMESTAMP_TZ</code></h3>
<p><code>TO_TIMESTAMP_TZ</code> es una función utilizada para convertir cadenas de texto (strings) en valores de fecha y hora con información de zona horaria. Es particularmente útil cuando se trabaja con fuentes de datos que incluyen la zona horaria en el texto de la fecha y hora, y se desea preservar esta información al almacenarla en la base de datos.</p>
<p>El formato ISO 8601 es un estándar internacional para la representación de fechas y horas, y tiene la forma <code>YYYY-MM-DDTHH:MM:SSZ</code> para UTC, o <code>YYYY-MM-DDTHH:MM:SS+HH:MM</code> para otras zonas horarias.</p>
<h4 id="ejemplo-de-to_timestamp_tz-con-formato-iso-8601">Ejemplo de <code>TO_TIMESTAMP_TZ</code> con formato ISO 8601:</h4>
<p>Para convertir una fecha y hora en formato ISO 8601 a un valor <code>TIMESTAMP WITH TIME ZONE</code>:</p>
<pre><code class="language-sql"><span class="hljs-keyword">SELECT</span> TO_TIMESTAMP_TZ(<span class="hljs-string">&#x27;2024-04-07T20:30:00+01:00&#x27;</span>, <span class="hljs-string">&#x27;YYYY-MM-DD&quot;T&quot;HH24:MI:SS:TZH:TZM&#x27;</span>) <span class="hljs-keyword">AS</span> fecha_hora_con_zona <span class="hljs-keyword">FROM</span> DUAL;
</code></pre>
<p>En este ejemplo, la cadena <code>'2024-04-07T20:30:00+01:00'</code> se convierte en un valor de fecha y hora teniendo en cuenta la zona horaria (<code>+01:00</code>). La parte <code>T</code> en el formato simplemente se usa para separar la fecha de la hora, siguiendo el estándar ISO 8601. <code>TZH</code> y <code>TZM</code> se utilizan para especificar la zona horaria, donde <code>TZH</code> representa las horas de la zona horaria y <code>TZM</code> los minutos.</p>
<h3 id="consideraciones">Consideraciones</h3>
<ul>
<li>La precisión y soporte para <code>TIMESTAMP</code> y <code>TO_TIMESTAMP_TZ</code> pueden variar entre diferentes DBMS. Es importante revisar la documentación específica del sistema que estás utilizando.</li>
<li>Mantener la información de la zona horaria puede ser crucial para aplicaciones que operan a nivel global, para asegurar que los eventos o transacciones se registren con la hora local correcta.</li>
<li>Al trabajar con zonas horarias, es importante considerar el efecto del horario de verano (DST) y cómo el DBMS maneja estos cambios.</li>
</ul>
<p>Este manejo avanzado de fechas y horas permite una gran flexibilidad y precisión en el almacenamiento y consulta de datos relacionados con el tiempo, facilitando el desarrollo de aplicaciones robustas y precisas en el manejo del tiempo.</p>
<h3 id="uso-de-fechas-con-zona-horaria">Uso de Fechas con Zona Horaria</h3>
<p>Utilizar <code>TO_TIMESTAMP_TZ</code> con nombres de zona horaria como <code>America/Mexico_City</code> permite manejar de manera más precisa las fechas y horas, especialmente teniendo en cuenta las variaciones por cambios de horario de verano. Sin embargo, es importante mencionar que el soporte específico para nombres de zonas horarias (en lugar de desplazamientos de zona horaria numéricos) y la función <code>TO_TIMESTAMP_TZ</code> pueden variar según el sistema de gestión de bases de datos (DBMS) que estés utilizando. En sistemas como Oracle, por ejemplo, puedes hacerlo de la siguiente manera:</p>
<pre><code class="language-sql"><span class="hljs-keyword">SELECT</span> TO_TIMESTAMP_TZ(<span class="hljs-string">&#x27;2024-04-07 20:30:00 America/Mexico_City&#x27;</span>,
                       <span class="hljs-string">&#x27;YYYY-MM-DD HH24:MI:SS TZR&#x27;</span>) <span class="hljs-keyword">AS</span> fecha_hora_con_zona
<span class="hljs-keyword">FROM</span> DUAL;
</code></pre>
<p>En este ejemplo:</p>
<ul>
<li><code>'2024-04-07 20:30:00 America/Mexico_City'</code> es la cadena de texto que representa la fecha, hora y zona horaria.</li>
<li><code>'YYYY-MM-DD HH24:MI:SS TZR'</code> es el formato de la cadena. <code>TZR</code> representa la zona horaria basada en regiones, como <code>America/Mexico_City</code>.</li>
<li><code>TO_TIMESTAMP_TZ</code> convierte la cadena en un valor <code>TIMESTAMP WITH TIME ZONE</code>, teniendo en cuenta la zona horaria especificada.</li>
</ul>
<p>Este método considera automáticamente los ajustes por horario de verano según las reglas de la zona horaria especificada. Esto significa que, si la fecha y hora dadas caen dentro de un período de horario de verano, el ajuste correspondiente se aplicará al resultado.</p>
<p>Es esencial asegurarse de que el DBMS tenga la información más reciente sobre las zonas horarias, ya que las reglas para el horario de verano pueden cambiar. En sistemas como Oracle, esto puede implicar actualizar periódicamente la base de datos de zonas horarias con los últimos parches proporcionados por el fabricante.</p>
<p>Recuerda que este ejemplo está basado en cómo se haría en Oracle, y la sintaxis exacta o el soporte para los nombres de zonas horarias pueden variar en otros sistemas como PostgreSQL, MySQL, SQL Server, etc. Por lo tanto, es crucial consultar la documentación específica de tu DBMS para el manejo de fechas y horas con zonas horarias.</p>
<h3 id="uso-de-la-tabla-dual">Uso de la tabla DUAL</h3>
<p><code>FROM DUAL</code> es una sintaxis que se encuentra comúnmente en bases de datos Oracle. <code>DUAL</code> es una tabla especial en Oracle que se utiliza específicamente para realizar operaciones que no requieren una tabla real para trabajar. Aunque inicialmente se introdujo en Oracle, algunos otros sistemas de gestión de bases de datos (DBMS) han adoptado conceptos similares para proporcionar funcionalidad equivalente.</p>
<h3 id="propósitos-y-uso-de-dual">Propósitos y Uso de <code>DUAL</code></h3>
<ul>
<li>
<p><strong>Realizar cálculos o transformaciones de datos sin referenciar una tabla real</strong>: Puedes utilizar <code>DUAL</code> para ejecutar funciones o realizar cálculos que no dependen de los datos de una tabla específica. Por ejemplo, obtener la fecha y hora actual, realizar cálculos matemáticos, o llamar a funciones que retornan un valor específico.</p>
</li>
<li>
<p><strong>Pruebas de funciones y expresiones SQL</strong>: <code>DUAL</code> es útil para probar funciones y expresiones SQL rápidamente sin necesidad de crear y acceder a una tabla real, lo cual es especialmente útil durante el desarrollo y depuración de consultas SQL.</p>
</li>
</ul>
<h3 id="ejemplo-de-uso">Ejemplo de Uso</h3>
<p>Supongamos que quieres obtener la fecha y hora actual en Oracle. Puedes hacerlo utilizando <code>DUAL</code> de la siguiente manera:</p>
<pre><code class="language-sql"><span class="hljs-keyword">SELECT</span> SYSDATE <span class="hljs-keyword">FROM</span> DUAL;
</code></pre>
<p><code>SYSDATE</code> es una función en Oracle que devuelve la fecha y hora actuales del sistema. Al seleccionar <code>SYSDATE FROM DUAL</code>, le estás diciendo a Oracle que ejecute esta función sin necesidad de consultar datos de una tabla específica.</p>
<h3 id="en-otros-sistemas-de-bases-de-datos">En Otros Sistemas de Bases de Datos</h3>
<p>En otros sistemas de gestión de bases de datos, como PostgreSQL o MySQL, la necesidad de <code>FROM DUAL</code> puede no ser tan directa porque estos sistemas permiten seleccionar valores sin referenciar una tabla. Por ejemplo, en PostgreSQL y MySQL, puedes simplemente hacer:</p>
<pre><code class="language-sql"><span class="hljs-keyword">SELECT</span> NOW(); <span class="hljs-comment">-- PostgreSQL y MySQL para obtener la fecha y hora actual</span>
</code></pre>
<p>En estos casos, no necesitas <code>FROM DUAL</code> para ejecutar la consulta. Sin embargo, Oracle requiere que especifiques <code>FROM</code> en tus consultas <code>SELECT</code>, por lo que <code>DUAL</code> se usa cuando no hay una tabla real de la que obtener los datos.</p>
<h3 id="conclusión">Conclusión</h3>
<p><code>FROM DUAL</code> es un artefacto útil en Oracle y en sistemas de bases de datos que adoptan una sintaxis similar, permitiendo a los desarrolladores y administradores de bases de datos ejecutar consultas que no requieren datos de una tabla. Facilita la ejecución de funciones, pruebas y cálculos rápidos directamente desde el SQL sin la necesidad de acceder a tablas con datos.</p>
<h2 id="103-subconsultas">103. Subconsultas</h2>
<p>Las subconsultas, también conocidas como consultas anidadas, son una herramienta poderosa en SQL que permite utilizar los resultados de una consulta como parte de otra. Son especialmente útiles para realizar comparaciones complejas, cálculos y para filtrar datos basados en los resultados de otra consulta. Vamos a desglosar el concepto y uso de las subconsultas, enfocándonos en su aplicación sin el uso de <code>JOIN</code>.</p>
<h3 id="concepto-de-subconsulta">Concepto de Subconsulta</h3>
<p>Una subconsulta es, esencialmente, una consulta dentro de otra consulta. Puede aparecer en diversas partes de la consulta principal, incluyendo en la cláusula <code>SELECT</code>, <code>FROM</code>, o <code>WHERE</code>. Las subconsultas permiten realizar operaciones que serían difíciles o imposibles de lograr con una sola consulta o mediante el uso de joins.</p>
<h3 id="tipos-de-subconsultas">Tipos de Subconsultas</h3>
<ul>
<li>
<p><strong>Subconsultas en la cláusula <code>WHERE</code></strong>: Permiten filtrar los resultados de la consulta externa basándose en los resultados de la consulta interna. Pueden ser especialmente útiles para realizar comparaciones que implican valores máximos, mínimos, promedios, entre otros.</p>
</li>
<li>
<p><strong>Subconsultas en la cláusula <code>FROM</code></strong>: Se utilizan para crear un conjunto de resultados temporal que luego se utiliza como una tabla desde la cual la consulta externa puede seleccionar. Es como si creases una tabla al vuelo basada en los resultados de otra consulta.</p>
</li>
<li>
<p><strong>Subconsultas en la cláusula <code>SELECT</code></strong>: Estas subconsultas pueden usarse para incluir columnas calculadas en los resultados de la consulta principal que dependen de los valores obtenidos de otra consulta.</p>
</li>
</ul>
<h3 id="ejemplos-de-subconsulta">Ejemplos de Subconsulta</h3>
<h4 id="subconsulta-en-where">Subconsulta en <code>WHERE</code></h4>
<p>Supongamos que tienes una tabla <code>empleados</code> con los campos <code>id_empleado</code>, <code>nombre</code>, <code>departamento_id</code> y <code>salario</code>. Si quisieras encontrar los empleados que ganan más que el promedio de salario en su departamento, podrías usar una subconsulta en la cláusula <code>WHERE</code>:</p>
<pre><code class="language-sql"><span class="hljs-keyword">SELECT</span> nombre, salario
<span class="hljs-keyword">FROM</span> empleados
<span class="hljs-keyword">WHERE</span> salario <span class="hljs-operator">&gt;</span> (
    <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">AVG</span>(salario)
    <span class="hljs-keyword">FROM</span> empleados
    <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> departamento_id
);
</code></pre>
<h4 id="subconsulta-en-from">Subconsulta en <code>FROM</code></h4>
<p>Si necesitas listar el salario máximo de cada departamento, podrías hacer una subconsulta en la cláusula <code>FROM</code> para crear una vista temporal de los salarios máximos por departamento y luego seleccionar de esta vista:</p>
<pre><code class="language-sql"><span class="hljs-keyword">SELECT</span> d.nombre_departamento, m.salario_maximo
<span class="hljs-keyword">FROM</span> (
    <span class="hljs-keyword">SELECT</span> departamento_id, <span class="hljs-built_in">MAX</span>(salario) <span class="hljs-keyword">as</span> salario_maximo
    <span class="hljs-keyword">FROM</span> empleados
    <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> departamento_id
) <span class="hljs-keyword">AS</span> m
<span class="hljs-keyword">JOIN</span> departamentos d <span class="hljs-keyword">ON</span> m.departamento_id <span class="hljs-operator">=</span> d.id_departamento;
</code></pre>
<h4 id="subconsulta-en-select">Subconsulta en <code>SELECT</code></h4>
<p>Para incluir en tus resultados una columna calculada que indique, por ejemplo, el salario promedio de la empresa, puedes utilizar una subconsulta en la cláusula <code>SELECT</code>:</p>
<pre><code class="language-sql"><span class="hljs-keyword">SELECT</span> nombre, salario, (
    <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">AVG</span>(salario)
    <span class="hljs-keyword">FROM</span> empleados
) <span class="hljs-keyword">AS</span> salario_promedio
<span class="hljs-keyword">FROM</span> empleados;
</code></pre>
<h3 id="consideraciones-1">Consideraciones</h3>
<ul>
<li>Las subconsultas deben estar encerradas entre paréntesis.</li>
<li>Una subconsulta que aparece en la cláusula <code>WHERE</code> o <code>SELECT</code> debe retornar un único valor si se compara directamente con otro valor (a menos que se utilicen operadores como <code>IN</code>, <code>ANY</code>, <code>ALL</code>, etc.).</li>
<li>Las subconsultas pueden impactar negativamente el rendimiento, especialmente si no están bien optimizadas o si operan sobre grandes conjuntos de datos. Es importante analizar y optimizar las subconsultas para asegurar un rendimiento adecuado.</li>
</ul>
<p>Las subconsultas ofrecen una flexibilidad increíble en la manipulación y análisis de datos, permitiendo construir consultas que de otra manera requerirían múltiples pasos o incluso procedimientos almacenados. Sin embargo, su uso debe ser cuidadoso para evitar impactos negativos en el rendimiento.</p>
<h2 id="104-consultas-anidadas">104. Consultas anidadas</h2>
<p>Las consultas anidadas usando <code>JOIN</code> son una técnica poderosa en SQL que permite combinar filas de dos o más tablas basadas en una columna relacionada entre ellas. A diferencia de las subconsultas simples, que generalmente se utilizan para realizar operaciones de selección o condición dentro de una misma tabla, las consultas anidadas con <code>JOIN</code> amplían esta funcionalidad permitiendo realizar operaciones más complejas que involucran múltiples tablas. Esto es particularmente útil para extraer datos relacionados que están distribuidos en diferentes tablas de una base de datos.</p>
<h3 id="concepto-de-consultas-anidadas-con-join">Concepto de Consultas Anidadas con <code>JOIN</code></h3>
<p>Una consulta anidada con <code>JOIN</code> implica utilizar una subconsulta (una consulta dentro de otra consulta) como una de las tablas en una operación de <code>JOIN</code>. Esta técnica es útil cuando necesitas filtrar o procesar datos de una tabla antes de unirlos con otra tabla. Esencialmente, permite pre-seleccionar, filtrar o transformar datos de una tabla en una subconsulta antes de realizar el <code>JOIN</code>.</p>
<h3 id="ejemplos-de-consultas-anidadas-usando-join">Ejemplos de Consultas Anidadas Usando <code>JOIN</code></h3>
<p>Imagina que tienes dos tablas: <code>empleados</code> (con campos <code>id_empleado</code>, <code>nombre</code>, y <code>departamento_id</code>) y <code>departamentos</code> (con campos <code>id_departamento</code> y <code>nombre_departamento</code>). Quieres obtener una lista de empleados junto con el nombre de su departamento, pero solo para aquellos departamentos que tienen más de 10 empleados.</p>
<h4 id="usando-una-subconsulta-en-join">Usando una Subconsulta en <code>JOIN</code></h4>
<pre><code class="language-sql"><span class="hljs-keyword">SELECT</span> e.nombre, d.nombre_departamento
<span class="hljs-keyword">FROM</span> empleados e
<span class="hljs-keyword">JOIN</span> (
    <span class="hljs-keyword">SELECT</span> id_departamento
    <span class="hljs-keyword">FROM</span> empleados
    <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> departamento_id
    <span class="hljs-keyword">HAVING</span> <span class="hljs-built_in">COUNT</span>(id_empleado) <span class="hljs-operator">&gt;</span> <span class="hljs-number">10</span>
) <span class="hljs-keyword">AS</span> deptos_grandes <span class="hljs-keyword">ON</span> e.departamento_id <span class="hljs-operator">=</span> deptos_grandes.id_departamento
<span class="hljs-keyword">JOIN</span> departamentos d <span class="hljs-keyword">ON</span> e.departamento_id <span class="hljs-operator">=</span> d.id_departamento;
</code></pre>
<p>En este ejemplo, la subconsulta selecciona los <code>id_departamento</code> que tienen más de 10 empleados. Luego, esta subconsulta se une con la tabla <code>empleados</code> para filtrar solo aquellos empleados que pertenecen a estos departamentos. Finalmente, se realiza otro <code>JOIN</code> con la tabla <code>departamentos</code> para obtener el nombre del departamento.</p>
<h3 id="ventajas-de-las-consultas-anidadas-con-join">Ventajas de las Consultas Anidadas con <code>JOIN</code></h3>
<ul>
<li><strong>Flexibilidad</strong>: Permiten un alto grado de flexibilidad al permitirte pre-procesar los datos de una tabla antes de unirlos con otra tabla.</li>
<li><strong>Eficiencia</strong>: Pueden ser más eficientes que realizar múltiples consultas separadas o complejas condiciones en las cláusulas <code>WHERE</code> o <code>HAVING</code>, especialmente si las subconsultas reducen significativamente el tamaño del conjunto de datos antes del <code>JOIN</code>.</li>
<li><strong>Organización</strong>: Ayudan a organizar y simplificar consultas complejas, haciendo que el proceso de desarrollo y depuración de consultas sea más manejable.</li>
</ul>
<h3 id="consideraciones-2">Consideraciones</h3>
<ul>
<li><strong>Rendimiento</strong>: Aunque las consultas anidadas con <code>JOIN</code> pueden ser poderosas, también pueden afectar el rendimiento si no se utilizan cuidadosamente. Es crucial analizar y optimizar estas consultas, especialmente en bases de datos grandes.</li>
<li><strong>Legibilidad</strong>: A medida que las consultas se vuelven más complejas, también puede disminuir su legibilidad. Mantener una estructura clara y comentarios adecuados puede ayudar a mitigar este problema.</li>
</ul>
<p>Las consultas anidadas con <code>JOIN</code> son una herramienta avanzada en el arsenal de SQL que, cuando se usan correctamente, pueden proporcionar soluciones eficientes y elegantes para problemas de datos complejos.</p>
<h3 id="uso-de-having">Uso de HAVING</h3>
<p>La cláusula <code>HAVING</code> en SQL es una herramienta poderosa usada para filtrar los resultados de una consulta que utiliza la cláusula <code>GROUP BY</code>. Mientras que <code>WHERE</code> filtra filas antes de que se agrupen, <code>HAVING</code> filtra los grupos creados por <code>GROUP BY</code> basándose en una condición especificada. Esto es especialmente útil para trabajar con funciones de agregación, donde deseas aplicar condiciones a un conjunto de datos agregados, como la suma total, el promedio, el conteo, etc.</p>
<h3 id="uso-básico-de-having">Uso Básico de <code>HAVING</code></h3>
<p>Supongamos que tienes una tabla llamada <code>ventas</code> con las siguientes columnas: <code>id_venta</code>, <code>fecha</code>, <code>monto</code> y <code>vendedor_id</code>. Si quisieras encontrar los vendedores que han generado ingresos por encima de un cierto umbral, podrías usar <code>GROUP BY</code> para agrupar las ventas por <code>vendedor_id</code> y luego <code>HAVING</code> para filtrar solo aquellos grupos que cumplan con tu criterio de ingresos.</p>
<pre><code class="language-sql"><span class="hljs-keyword">SELECT</span> vendedor_id, <span class="hljs-built_in">SUM</span>(monto) <span class="hljs-keyword">AS</span> total_ventas
<span class="hljs-keyword">FROM</span> ventas
<span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> vendedor_id
<span class="hljs-keyword">HAVING</span> <span class="hljs-built_in">SUM</span>(monto) <span class="hljs-operator">&gt;</span> <span class="hljs-number">10000</span>;
</code></pre>
<p>En este ejemplo, primero se agrupan las ventas por <code>vendedor_id</code>, luego se suma el <code>monto</code> de las ventas para cada vendedor, y finalmente, la cláusula <code>HAVING</code> filtra y muestra solo aquellos vendedores cuyo total de ventas supera los 10,000.</p>
<h3 id="diferencia-entre-where-y-having">Diferencia Entre <code>WHERE</code> y <code>HAVING</code></h3>
<ul>
<li><code>WHERE</code> se utiliza para filtrar filas antes de que sean agrupadas por <code>GROUP BY</code>.</li>
<li><code>HAVING</code> se utiliza para filtrar grupos después de que han sido formados por <code>GROUP BY</code>.</li>
</ul>
<p>Es importante notar que puedes usar <code>WHERE</code> y <code>HAVING</code> en la misma consulta. <code>WHERE</code> filtrará los datos antes de que sean agrupados, y <code>HAVING</code> aplicará un filtro adicional a los grupos resultantes.</p>
<h3 id="ejemplo-combinando-where-y-having">Ejemplo Combinando <code>WHERE</code> y <code>HAVING</code></h3>
<p>Siguiendo el ejemplo anterior, si solo te interesan las ventas realizadas en el año 2023 y además quieres aplicar el filtro de ingresos, podrías escribir la consulta de la siguiente manera:</p>
<pre><code class="language-sql"><span class="hljs-keyword">SELECT</span> vendedor_id, <span class="hljs-built_in">SUM</span>(monto) <span class="hljs-keyword">AS</span> total_ventas
<span class="hljs-keyword">FROM</span> ventas
<span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">YEAR</span>(fecha) <span class="hljs-operator">=</span> <span class="hljs-number">2023</span>
<span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> vendedor_id
<span class="hljs-keyword">HAVING</span> <span class="hljs-built_in">SUM</span>(monto) <span class="hljs-operator">&gt;</span> <span class="hljs-number">10000</span>;
</code></pre>
<p>Aquí, la cláusula <code>WHERE</code> primero asegura que solo las ventas del año 2023 sean consideradas. Luego, <code>GROUP BY</code> agrupa estas ventas por <code>vendedor_id</code>, y <code>HAVING</code> filtra estos grupos para mostrar solo aquellos vendedores cuyo total de ventas excede los 10,000.</p>
<h3 id="consideraciones-3">Consideraciones</h3>
<ul>
<li><code>HAVING</code> puede usarse sin <code>GROUP BY</code> para filtrar resultados agregados a nivel global. Sin embargo, su uso más común y poderoso es en combinación con <code>GROUP BY</code> para aplicar condiciones a grupos específicos.</li>
<li>Al igual que con otras cláusulas de SQL, el rendimiento de las consultas que usan <code>HAVING</code> puede variar significativamente con el tamaño del conjunto de datos y la complejidad de las condiciones de filtro. Es importante considerar la optimización de consultas y posiblemente el uso de índices para mejorar el rendimiento.</li>
</ul>
<p>La cláusula <code>HAVING</code> es una herramienta esencial en SQL para el análisis de datos agregados, permitiendo a los usuarios realizar consultas complejas y obtener insights significativos de grandes conjuntos de datos.</p>
<h3 id="uso-de-with">Uso de WITH</h3>
<p>La cláusula <code>WITH</code>, también conocida como Common Table Expressions (CTE), es una característica muy útil en SQL que permite crear una o más tablas temporales que existen únicamente durante la ejecución de la consulta. Los CTE ofrecen una manera de organizar y simplificar consultas SQL complejas, haciéndolas más legibles y, en muchos casos, mejorando el rendimiento. Son especialmente útiles en situaciones que involucran consultas recursivas, consultas con múltiples pasos que requieren el uso de los mismos datos intermedios varias veces, o simplemente para hacer que la consulta sea más comprensible separando en pasos lógicos.</p>
<h3 id="estructura-básica-de-with">Estructura Básica de <code>WITH</code></h3>
<p>La estructura básica de un CTE es la siguiente:</p>
<pre><code class="language-sql"><span class="hljs-keyword">WITH</span> NombreCTE <span class="hljs-keyword">AS</span> (
    <span class="hljs-comment">-- Aquí va tu consulta SQL</span>
)
<span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> NombreCTE;
</code></pre>
<p>Puedes definir varios CTE en una sola consulta, separándolos con comas:</p>
<pre><code class="language-sql"><span class="hljs-keyword">WITH</span> CTE1 <span class="hljs-keyword">AS</span> (
    <span class="hljs-comment">-- Consulta 1</span>
), CTE2 <span class="hljs-keyword">AS</span> (
    <span class="hljs-comment">-- Consulta 2 que podría incluso referenciar a CTE1</span>
)
<span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> CTE1 <span class="hljs-keyword">JOIN</span> CTE2 <span class="hljs-keyword">ON</span> CTE1.columna <span class="hljs-operator">=</span> CTE2.columna;
</code></pre>
<h3 id="ejemplo-práctico-de-uso-de-with">Ejemplo Práctico de Uso de <code>WITH</code></h3>
<p>Imagina que estás trabajando con una base de datos de una tienda en línea y quieres obtener los nombres de los productos más vendidos junto con la información de los proveedores. Supongamos que las ventas están registradas en una tabla <code>ventas</code> y la información del producto está en una tabla <code>productos</code>. Podrías usar <code>WITH</code> para simplificar la consulta de la siguiente manera:</p>
<pre><code class="language-sql"><span class="hljs-keyword">WITH</span> VentasTotales <span class="hljs-keyword">AS</span> (
    <span class="hljs-keyword">SELECT</span> producto_id, <span class="hljs-built_in">SUM</span>(cantidad) <span class="hljs-keyword">AS</span> total_vendido
    <span class="hljs-keyword">FROM</span> ventas
    <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> producto_id
), ProductosMasVendidos <span class="hljs-keyword">AS</span> (
    <span class="hljs-keyword">SELECT</span> p.nombre, p.proveedor_id, v.total_vendido
    <span class="hljs-keyword">FROM</span> productos p
    <span class="hljs-keyword">JOIN</span> VentasTotales v <span class="hljs-keyword">ON</span> p.id <span class="hljs-operator">=</span> v.producto_id
    <span class="hljs-keyword">WHERE</span> v.total_vendido <span class="hljs-operator">&gt;</span> <span class="hljs-number">100</span> <span class="hljs-comment">-- Suponiendo que quieres productos con más de 100 ventas</span>
)
<span class="hljs-keyword">SELECT</span> pmv.nombre, proveedor.nombre
<span class="hljs-keyword">FROM</span> ProductosMasVendidos pmv
<span class="hljs-keyword">JOIN</span> proveedores <span class="hljs-keyword">ON</span> pmv.proveedor_id <span class="hljs-operator">=</span> proveedores.id;
</code></pre>
<h3 id="ventajas-del-uso-de-with">Ventajas del Uso de <code>WITH</code></h3>
<ul>
<li><strong>Legibilidad</strong>: Al separar las consultas en bloques lógicos, <code>WITH</code> hace que las consultas complejas sean más fáciles de entender y mantener.</li>
<li><strong>Reusabilidad</strong>: Permite reutilizar los resultados de una subconsulta múltiples veces en una consulta más grande sin necesidad de duplicar código.</li>
<li><strong>Facilita consultas recursivas</strong>: Los CTE recursivos son una forma potente de tratar con datos jerárquicos, como estructuras de árboles o grafos, que serían difíciles o imposibles de manejar con consultas SQL estándar.</li>
</ul>
<h3 id="consideraciones-4">Consideraciones</h3>
<ul>
<li><strong>Desempeño</strong>: Aunque los CTE pueden mejorar la legibilidad de las consultas, su impacto en el rendimiento depende de cómo el sistema de gestión de base de datos (DBMS) optimiza la ejecución de la consulta. En algunos casos, un CTE puede ser menos eficiente que una subconsulta equivalente, mientras que en otros, puede ser igual o incluso más eficiente.</li>
<li><strong>Soporte del DBMS</strong>: La disponibilidad y el comportamiento específico de <code>WITH</code> y los CTE pueden variar entre diferentes sistemas de bases de datos. Es importante revisar la documentación del DBMS que estás utilizando.</li>
</ul>
<p>En resumen, los CTE ofrecen una manera flexible y potente de estructurar consultas SQL, haciéndolas más claras y, en muchos casos, más eficientes. Su capacidad para desglosar consultas complejas en partes más manejables los convierte en una herramienta valiosa para cualquier desarrollador o analista de bases de datos.</p>
<h2 id="105-uso-de-índices">105. Uso de Índices</h2>
<p>El uso de índices en bases de datos es una técnica fundamental para mejorar la eficiencia de las operaciones de búsqueda, consulta y actualización. Los índices son estructuras de datos especiales que el sistema de gestión de bases de datos (DBMS) mantiene para permitir accesos rápidos a las filas de una tabla. Funcionan de manera similar al índice de un libro: en lugar de leer todo el libro (o tabla) para encontrar un capítulo (o fila) específico, miras en el índice para encontrar rápidamente la página (o posición de fila) que necesitas.</p>
<h3 id="cómo-funcionan-los-índices">Cómo Funcionan los Índices</h3>
<p>Los índices son creados en columnas específicas de una tabla. Estas columnas son generalmente las que se usan con frecuencia en cláusulas <code>WHERE</code>, <code>JOIN</code>, o como parte de una operación de ordenamiento (<code>ORDER BY</code>). Al crear un índice en una columna, el DBMS construye una estructura de datos interna (como un árbol B, un árbol B+, o un hash) que mapea los valores de esa columna a las direcciones físicas o lógicas de las filas correspondientes en el disco.</p>
<h3 id="tipos-de-índices">Tipos de Índices</h3>
<ul>
<li><strong>Índices únicos</strong>: Aseguran que no haya dos filas con el mismo valor en la columna o columnas indexadas. Son útiles para mantener la integridad de los datos, como en el caso de un ID de usuario.</li>
<li><strong>Índices no únicos</strong>: Permiten valores duplicados y son útiles para mejorar el rendimiento de las consultas en columnas donde los datos tienden a repetirse.</li>
<li><strong>Índices compuestos</strong>: Se crean sobre más de una columna de una tabla. Son especialmente útiles cuando las consultas frecuentemente involucran operaciones sobre varias columnas.</li>
</ul>
<h3 id="ventajas-del-uso-de-índices">Ventajas del Uso de Índices</h3>
<ul>
<li><strong>Mejora del rendimiento de las consultas</strong>: Los índices pueden reducir significativamente el tiempo necesario para buscar y recuperar datos de una tabla.</li>
<li><strong>Eficiencia en las operaciones de <code>JOIN</code></strong>: Los índices en las columnas utilizadas en <code>JOIN</code> pueden hacer que estas operaciones sean mucho más rápidas.</li>
<li><strong>Mejora en la velocidad de ordenamiento de datos</strong>: Los índices pueden acelerar las operaciones de ordenamiento especificadas en <code>ORDER BY</code>.</li>
</ul>
<h3 id="consideraciones-al-usar-índices">Consideraciones al Usar Índices</h3>
<ul>
<li><strong>Costo de mantenimiento</strong>: Cada vez que se inserta, actualiza o elimina una fila en la tabla, todos los índices en esa tabla deben ser actualizados. Esto puede llevar a un sobrecoste en operaciones de escritura.</li>
<li><strong>Uso de espacio</strong>: Los índices ocupan espacio en el disco, que puede ser significativo dependiendo del tamaño de la tabla y el tipo de índice.</li>
<li><strong>Selección de columnas</strong>: No todas las columnas son buenos candidatos para la indexación. Generalmente, se deben indexar las columnas que se usan frecuentemente en las cláusulas <code>WHERE</code>, <code>JOIN</code>, o <code>ORDER BY</code>.</li>
</ul>
<h3 id="creación-de-un-índice">Creación de un Índice</h3>
<p>La sintaxis para crear un índice varía entre los sistemas de DBMS, pero el concepto es generalmente el mismo. Aquí tienes un ejemplo básico en SQL:</p>
<pre><code class="language-sql"><span class="hljs-keyword">CREATE</span> INDEX idx_columna <span class="hljs-keyword">ON</span> tabla(columna);
</code></pre>
<p>Este comando crea un índice no único en la <code>columna</code> de la <code>tabla</code> especificada.</p>
<h3 id="conclusión-1">Conclusión</h3>
<p>El uso adecuado de índices es crucial para el rendimiento de las bases de datos. Sin embargo, es importante usarlos de manera estratégica, ya que un exceso de índices o índices inapropiados pueden tener un impacto negativo en el rendimiento de la base de datos, especialmente en operaciones de escritura. La clave está en encontrar el equilibrio correcto entre la velocidad de lectura y la eficiencia de escritura, teniendo en cuenta las necesidades específicas de tu aplicación.</p>
<h3 id="ejemplo-de-uso-de-índices">Ejemplo de uso de Índices</h3>
<p>Vamos a ilustrar el uso de índices con un ejemplo práctico en un escenario de base de datos típico. Imaginemos que tenemos una base de datos de una librería en línea, con una tabla llamada <code>Pedidos</code> que registra todas las transacciones de los clientes. La tabla <code>Pedidos</code> tiene las siguientes columnas:</p>
<ul>
<li><code>id_pedido</code> (clave primaria)</li>
<li><code>id_cliente</code></li>
<li><code>fecha_pedido</code></li>
<li><code>monto_total</code></li>
<li><code>estado</code></li>
</ul>
<p>Supongamos que los usuarios de la base de datos a menudo necesitan buscar pedidos por <code>id_cliente</code> y <code>fecha_pedido</code>, y también filtrar por el <code>estado</code> del pedido. Sin embargo, la tabla <code>Pedidos</code> ha crecido significativamente y contiene millones de registros, haciendo que las consultas sean lentas, especialmente aquellas que buscan pedidos de un cliente específico dentro de un rango de fechas.</p>
<h3 id="creación-de-índices">Creación de Índices</h3>
<p>Para mejorar el rendimiento de estas consultas, podemos crear índices en las columnas <code>id_cliente</code>, <code>fecha_pedido</code> y <code>estado</code>.</p>
<h4 id="índice-en-id_cliente">Índice en <code>id_cliente</code></h4>
<pre><code class="language-sql"><span class="hljs-keyword">CREATE</span> INDEX idx_id_cliente <span class="hljs-keyword">ON</span> Pedidos(id_cliente);
</code></pre>
<p>Este índice ayudará a mejorar el rendimiento de las consultas que buscan pedidos por el <code>id_cliente</code>. Por ejemplo:</p>
<pre><code class="language-sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> Pedidos <span class="hljs-keyword">WHERE</span> id_cliente <span class="hljs-operator">=</span> <span class="hljs-number">12345</span>;
</code></pre>
<h4 id="índice-en-fecha_pedido">Índice en <code>fecha_pedido</code></h4>
<pre><code class="language-sql"><span class="hljs-keyword">CREATE</span> INDEX idx_fecha_pedido <span class="hljs-keyword">ON</span> Pedidos(fecha_pedido);
</code></pre>
<p>Este índice facilitará la búsqueda eficiente de pedidos por fecha. Es particularmente útil para consultas que involucran rangos de fechas:</p>
<pre><code class="language-sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> Pedidos <span class="hljs-keyword">WHERE</span> fecha_pedido <span class="hljs-keyword">BETWEEN</span> <span class="hljs-string">&#x27;2024-01-01&#x27;</span> <span class="hljs-keyword">AND</span> <span class="hljs-string">&#x27;2024-01-31&#x27;</span>;
</code></pre>
<h4 id="índice-compuesto-en-id_cliente-y-fecha_pedido">Índice Compuesto en <code>id_cliente</code> y <code>fecha_pedido</code></h4>
<p>Si las consultas comunes implican buscar por <code>id_cliente</code> y filtrar por un rango de <code>fecha_pedido</code>, podría ser beneficioso crear un índice compuesto que cubra ambas columnas:</p>
<pre><code class="language-sql"><span class="hljs-keyword">CREATE</span> INDEX idx_cliente_fecha <span class="hljs-keyword">ON</span> Pedidos(id_cliente, fecha_pedido);
</code></pre>
<p>Este índice compuesto es óptimo para consultas como:</p>
<pre><code class="language-sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> Pedidos <span class="hljs-keyword">WHERE</span> id_cliente <span class="hljs-operator">=</span> <span class="hljs-number">12345</span> <span class="hljs-keyword">AND</span> fecha_pedido <span class="hljs-keyword">BETWEEN</span> <span class="hljs-string">&#x27;2024-01-01&#x27;</span> <span class="hljs-keyword">AND</span> <span class="hljs-string">&#x27;2024-01-31&#x27;</span>;
</code></pre>
<h4 id="índice-en-estado">Índice en <code>estado</code></h4>
<pre><code class="language-sql"><span class="hljs-keyword">CREATE</span> INDEX idx_estado <span class="hljs-keyword">ON</span> Pedidos(estado);
</code></pre>
<p>Este índice mejora las consultas que filtran por el <code>estado</code> del pedido, como buscar todos los pedidos que están &quot;Enviados&quot;:</p>
<pre><code class="language-sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> Pedidos <span class="hljs-keyword">WHERE</span> estado <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;Enviado&#x27;</span>;
</code></pre>
<h3 id="consideraciones-5">Consideraciones</h3>
<p>Al decidir qué índices crear, es importante considerar cómo se usan los datos:</p>
<ul>
<li><strong>Análisis de consultas</strong>: Identifica las consultas más frecuentes o críticas para el rendimiento y diseña índices que las optimicen.</li>
<li><strong>Índices compuestos</strong>: Siempre se utilizan de izquierda a derecha en su definición. Asegúrate de que el orden de las columnas en el índice compuesto refleje el uso común en las consultas.</li>
<li><strong>Mantenimiento de índices</strong>: Los índices incrementan el tiempo y los recursos necesarios para las operaciones de escritura (<code>INSERT</code>, <code>UPDATE</code>, <code>DELETE</code>) porque el DBMS debe actualizar los índices además de los datos. Evalúa el impacto en el rendimiento de escritura frente a las ganancias en rendimiento de lectura.</li>
</ul>
<p>Este ejemplo ilustra cómo los índices pueden ser una herramienta poderosa para mejorar el rendimiento de las consultas en bases de datos grandes, permitiendo búsquedas y filtrados mucho más rápidos en columnas clave.</p>
<h3 id="índices-únicos">Índices únicos</h3>
<p>Para asegurar que los valores en una columna (o un conjunto de columnas) sean únicos en una tabla, puedes crear un índice único. Un índice único no solo mejora el rendimiento de las consultas sobre esas columnas, sino que también previene la inserción de filas con valores duplicados en las columnas indexadas, lo cual es útil para mantener la integridad de los datos.</p>
<h3 id="ejemplo-de-creación-de-un-índice-único">Ejemplo de Creación de un Índice Único</h3>
<p>Supongamos que tienes una tabla llamada <code>Usuarios</code> con las siguientes columnas:</p>
<ul>
<li><code>id_usuario</code> (clave primaria)</li>
<li><code>nombre_usuario</code></li>
<li><code>email</code></li>
<li><code>fecha_registro</code></li>
</ul>
<p>Quieres asegurarte de que el <code>email</code> de cada usuario sea único en la tabla <code>Usuarios</code>, porque cada dirección de correo electrónico debe estar asociada con un solo usuario. Para lograr esto, puedes crear un índice único en la columna <code>email</code>.</p>
<h4 id="crear-un-índice-único-en-email">Crear un Índice Único en <code>email</code></h4>
<pre><code class="language-sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">UNIQUE</span> INDEX idx_email_unico <span class="hljs-keyword">ON</span> Usuarios(email);
</code></pre>
<p>Este comando crea un índice único llamado <code>idx_email_unico</code> en la columna <code>email</code> de la tabla <code>Usuarios</code>. Si intentas insertar o actualizar filas de manera que dos filas tengan el mismo valor en la columna <code>email</code>, el sistema de gestión de bases de datos (DBMS) rechazará la operación y mostrará un error.</p>
<h3 id="uso-práctico">Uso Práctico</h3>
<p>El uso de índices únicos es particularmente importante en campos que identifican de manera exclusiva a los registros, como pueden ser:</p>
<ul>
<li>Direcciones de correo electrónico en una tabla de usuarios.</li>
<li>Números de identificación nacional o pasaporte en registros de personas.</li>
<li>Nombres de usuario o IDs de inicio de sesión.</li>
</ul>
<h4 id="intento-de-inserción-duplicada">Intento de Inserción Duplicada</h4>
<p>Aquí hay un ejemplo de lo que sucedería si intentas insertar una fila con un valor duplicado en la columna <code>email</code>:</p>
<pre><code class="language-sql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> Usuarios (nombre_usuario, email, fecha_registro)
<span class="hljs-keyword">VALUES</span> (<span class="hljs-string">&#x27;NuevoUsuario&#x27;</span>, <span class="hljs-string">&#x27;usuarioexistente@email.com&#x27;</span>, <span class="hljs-string">&#x27;2024-01-01&#x27;</span>);
</code></pre>
<p>Si ya existe una fila en <code>Usuarios</code> con el <code>email</code> &quot;<a href="mailto:usuarioexistente@email.com">usuarioexistente@email.com</a>&quot;, esta operación de inserción fallará debido al índice único.</p>
<h3 id="beneficios-de-los-índices-únicos">Beneficios de los Índices Únicos</h3>
<ul>
<li><strong>Integridad de Datos</strong>: Asegura que no se pueden insertar datos duplicados en las columnas clave, lo que es crucial para mantener la integridad de los datos.</li>
<li><strong>Mejora del Rendimiento</strong>: Optimiza las operaciones de búsqueda, actualización y eliminación de datos al proporcionar una vía rápida para localizar registros únicos.</li>
</ul>
<h3 id="consideraciones-6">Consideraciones</h3>
<ul>
<li>Al diseñar tu base de datos, es importante considerar cuidadosamente qué campos deberían ser únicos para evitar errores y problemas de integridad de datos.</li>
<li>Aunque los índices únicos son herramientas poderosas para la integridad de los datos, también añaden un sobrecoste a las operaciones de inserción y actualización, ya que el DBMS debe verificar la unicidad cada vez que se modifican los datos.</li>
</ul>
<p>Este enfoque para garantizar valores únicos a través de índices es ampliamente soportado por la mayoría de los sistemas de gestión de bases de datos, incluyendo MySQL, PostgreSQL, SQL Server, Oracle, y muchos otros.</p>
<h3 id="índices-compuestos">Índices compuestos</h3>
<p>Un índice compuesto es un índice que abarca más de una columna en una tabla. Crear un índice compuesto puede ser muy útil cuando las consultas frecuentemente involucran operaciones de filtrado, ordenamiento o join que abarcan múltiples columnas. Al incluir varias columnas en un único índice, el sistema de gestión de bases de datos (DBMS) puede mejorar significativamente el rendimiento de estas consultas.</p>
<h3 id="ejemplo-de-creación-de-un-índice-compuesto">Ejemplo de Creación de un Índice Compuesto</h3>
<p>Consideremos una tabla <code>Empleados</code> que tiene, entre otros, los campos <code>Nombre</code> y <code>Apellido</code>. Supongamos que comúnmente realizas consultas que buscan empleados usando tanto el nombre como el apellido. En este caso, un índice compuesto en ambas columnas puede mejorar el rendimiento de estas consultas.</p>
<h4 id="creación-de-la-tabla-empleados">Creación de la Tabla <code>Empleados</code></h4>
<p>Imaginemos que la tabla se define así:</p>
<pre><code class="language-sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> Empleados (
    id_empleado <span class="hljs-type">INT</span> <span class="hljs-keyword">PRIMARY</span> KEY,
    Nombre <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">50</span>),
    Apellido <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">50</span>),
    Departamento <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">50</span>),
    Fecha_Contratacion <span class="hljs-type">DATE</span>
);
</code></pre>
<h4 id="crear-un-índice-compuesto-en-nombre-y-apellido">Crear un Índice Compuesto en <code>Nombre</code> y <code>Apellido</code></h4>
<p>Para crear un índice compuesto en las columnas <code>Nombre</code> y <code>Apellido</code>, podrías usar el siguiente comando SQL:</p>
<pre><code class="language-sql"><span class="hljs-keyword">CREATE</span> INDEX idx_nombre_apellido <span class="hljs-keyword">ON</span> Empleados(Nombre, Apellido);
</code></pre>
<p>Este comando crea un índice compuesto llamado <code>idx_nombre_apellido</code> que abarca las columnas <code>Nombre</code> y <code>Apellido</code>. Ahora, cuando ejecutes consultas que busquen empleados por nombre y apellido, el DBMS podrá utilizar este índice para realizar la búsqueda de manera más eficiente.</p>
<h3 id="uso-práctico-del-índice-compuesto">Uso Práctico del Índice Compuesto</h3>
<p>El índice compuesto <code>idx_nombre_apellido</code> es particularmente útil para consultas como:</p>
<pre><code class="language-sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> Empleados <span class="hljs-keyword">WHERE</span> Nombre <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;Juan&#x27;</span> <span class="hljs-keyword">AND</span> Apellido <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;Pérez&#x27;</span>;
</code></pre>
<p>O para consultas que ordenan los resultados por las columnas indexadas:</p>
<pre><code class="language-sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> Empleados <span class="hljs-keyword">WHERE</span> Departamento <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;Ventas&#x27;</span> <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> Nombre, Apellido;
</code></pre>
<p>Aunque la cláusula <code>WHERE</code> solo filtre por <code>Departamento</code>, el índice compuesto puede mejorar el rendimiento del ordenamiento (<code>ORDER BY</code>) si el filtrado resulta en un subconjunto de filas suficientemente pequeño.</p>
<h3 id="beneficios-de-los-índices-compuestos">Beneficios de los Índices Compuestos</h3>
<ul>
<li><strong>Eficiencia en Consultas</strong>: Los índices compuestos pueden hacer que las consultas que filtran o ordenan basándose en múltiples columnas sean mucho más rápidas.</li>
<li><strong>Optimización de <code>JOIN</code></strong>: También pueden optimizar las operaciones de <code>JOIN</code> que implican las columnas indexadas.</li>
<li><strong>Mejora en el Ordenamiento de Datos</strong>: Aceleran las operaciones de ordenamiento que usan las columnas indexadas.</li>
</ul>
<h3 id="consideraciones-7">Consideraciones</h3>
<ul>
<li><strong>Orden de las Columnas</strong>: El orden de las columnas en un índice compuesto es crucial. El índice será más efectivo para las consultas que utilicen las columnas en el mismo orden en que se definió el índice.</li>
<li><strong>Uso de Espacio y Rendimiento de Escritura</strong>: Al igual que con todos los índices, los índices compuestos ocupan espacio adicional en el disco y pueden hacer que las operaciones de inserción, actualización y eliminación sean más lentas debido a la necesidad de mantener el índice actualizado.</li>
</ul>
<p>Los índices compuestos son herramientas potentes para la optimización de consultas en bases de datos relacionales, pero deben usarse con cuidado, teniendo en cuenta el impacto en el espacio y el rendimiento de escritura.</p>
<h3 id="índices-compuestos-y-únicos">Índices compuestos y únicos</h3>
<p>Puedes hacer que un índice compuesto sea único. Esto garantizará que la combinación de valores en las columnas indexadas sea única en toda la tabla, lo cual es útil cuando quieres prevenir registros duplicados basados en un conjunto específico de columnas.</p>
<h3 id="creación-de-un-índice-compuesto-único">Creación de un Índice Compuesto Único</h3>
<p>Para seguir con el ejemplo anterior de la tabla <code>Empleados</code> y crear un índice compuesto único para las columnas <code>Nombre</code> y <code>Apellido</code>, usarías el siguiente comando SQL:</p>
<pre><code class="language-sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">UNIQUE</span> INDEX idx_nombre_apellido_unico <span class="hljs-keyword">ON</span> Empleados(Nombre, Apellido);
</code></pre>
<p>Este comando crea un índice único llamado <code>idx_nombre_apellido_unico</code> que cubre las columnas <code>Nombre</code> y <code>Apellido</code>. Con este índice en su lugar, cualquier intento de insertar o actualizar filas en la tabla <code>Empleados</code> que resulte en una combinación de <code>Nombre</code> y <code>Apellido</code> duplicada será rechazado por el sistema de gestión de bases de datos.</p>
<h3 id="ejemplo-práctico">Ejemplo Práctico</h3>
<p>Consideremos que ya tienes un empleado llamado &quot;Juan Pérez&quot; en la tabla <code>Empleados</code>. Si intentas insertar otro empleado con el mismo nombre y apellido:</p>
<pre><code class="language-sql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> Empleados (Nombre, Apellido, Departamento, Fecha_Contratacion)
<span class="hljs-keyword">VALUES</span> (<span class="hljs-string">&#x27;Juan&#x27;</span>, <span class="hljs-string">&#x27;Pérez&#x27;</span>, <span class="hljs-string">&#x27;Desarrollo&#x27;</span>, <span class="hljs-string">&#x27;2024-01-01&#x27;</span>);
</code></pre>
<p>Este intento de inserción fallará con un error de violación de índice único, ya que ya existe un empleado con el <code>Nombre</code> &quot;Juan&quot; y el <code>Apellido</code> &quot;Pérez&quot;.</p>
<h3 id="beneficios-de-los-índices-compuestos-únicos">Beneficios de los Índices Compuestos Únicos</h3>
<ul>
<li><strong>Integridad de Datos</strong>: Aseguran que no puedan existir dos filas con la misma combinación de valores en las columnas indexadas, lo cual es importante para evitar duplicados y mantener la integridad de los datos.</li>
<li><strong>Rendimiento de Consulta</strong>: Al igual que otros índices, un índice compuesto único también puede mejorar el rendimiento de las consultas que buscan o filtran datos basados en las columnas indexadas.</li>
</ul>
<h3 id="consideraciones-8">Consideraciones</h3>
<ul>
<li><strong>Selección de Columnas</strong>: Antes de crear un índice compuesto único, asegúrate de que la combinación de columnas realmente necesite ser única. Considera las reglas de negocio y los requisitos de la aplicación.</li>
<li><strong>Impacto en Operaciones de Escritura</strong>: Mientras que los índices únicos protegen contra datos duplicados, también incurren en un chequeo adicional durante las operaciones de inserción y actualización, lo que puede afectar el rendimiento de estas operaciones.</li>
<li><strong>Uso de Espacio</strong>: Los índices ocupan espacio adicional en el almacenamiento de la base de datos. Los índices compuestos únicos, al incluir múltiples columnas, pueden ocupar más espacio que los índices simples.</li>
</ul>
<p>Crear índices compuestos únicos es una práctica poderosa para la gestión de bases de datos, especialmente cuando se necesita asegurar la unicidad a través de múltiples campos. Esto permite a los diseñadores de bases de datos imponer restricciones de integridad de datos a nivel de estructura de datos, complementando las reglas de negocio aplicadas en la capa de aplicación.</p>
<h2 id="106-estrategias-para-mejorar-el-rendimiento">106. Estrategias para mejorar el rendimiento</h2>
<p>Mejorar el rendimiento de las bases de datos es crucial para mantener aplicaciones ágiles y eficientes, especialmente a medida que las bases de datos crecen en tamaño y complejidad. Aquí se describen varias estrategias fundamentales que pueden ayudar a optimizar el rendimiento de las consultas SQL y la gestión general de las bases de datos.</p>
<h3 id="1-uso-efectivo-de-índices">1. Uso Efectivo de Índices</h3>
<ul>
<li><strong>Crear Índices</strong>: Los índices son esenciales para acelerar las operaciones de búsqueda y consulta. Identifica las columnas que se utilizan con frecuencia en las cláusulas <code>WHERE</code>, <code>JOIN</code>, o <code>ORDER BY</code> para indexarlas.</li>
<li><strong>Índices Únicos y Compuestos</strong>: Utiliza índices únicos para asegurar la unicidad de los datos y considera índices compuestos para consultas que involucran múltiples columnas.</li>
<li><strong>Evitar Índices Innecesarios</strong>: Cada índice adicional consume recursos y ralentiza las operaciones de escritura (<code>INSERT</code>, <code>UPDATE</code>, <code>DELETE</code>). Mantén solo los índices que benefician el rendimiento de las consultas.</li>
</ul>
<h3 id="2-optimización-de-consultas">2. Optimización de Consultas</h3>
<ul>
<li><strong>Minimizar el Uso de <code>SELECT *</code></strong>: Especifica solo las columnas que necesitas en tus consultas <code>SELECT</code> para reducir la cantidad de datos transferidos y procesados.</li>
<li><strong>Usar Cláusulas <code>WHERE</code> Efectivas</strong>: Filtra los resultados lo más pronto posible en tus consultas para reducir el tamaño del conjunto de resultados.</li>
<li><strong>Dividir Consultas Complejas</strong>: Las consultas muy complejas pueden ser más lentas de ejecutar. Considera dividirlas en subconsultas más manejables si es posible.</li>
</ul>
<h3 id="3-normalización-y-desnormalización">3. Normalización y Desnormalización</h3>
<ul>
<li><strong>Normalización</strong>: Diseña tu base de datos para eliminar la redundancia de datos y asegurar la integridad mediante la normalización. Esto puede mejorar el rendimiento de escritura y simplificar el mantenimiento de la base de datos.</li>
<li><strong>Desnormalización</strong>: En algunos casos, la desnormalización (agregar redundancia deliberadamente) puede mejorar el rendimiento de lectura al reducir el número de <code>JOIN</code> necesarios.</li>
</ul>
<h3 id="4-particionamiento-de-tablas">4. Particionamiento de Tablas</h3>
<ul>
<li><strong>Particionamiento</strong>: Divide una tabla grande en partes más manejables basadas en ciertos criterios (como fechas o regiones geográficas). Esto puede mejorar significativamente el rendimiento de las consultas que pueden operar en una partición individual.</li>
</ul>
<h3 id="5-caching">5. Caching</h3>
<ul>
<li><strong>Cache de Resultados</strong>: Implementa caching en el nivel de aplicación para almacenar los resultados de consultas que se ejecutan con frecuencia, reduciendo así la carga en la base de datos.</li>
</ul>
<h3 id="6-gestión-de-conexiones">6. Gestión de Conexiones</h3>
<ul>
<li><strong>Pool de Conexiones</strong>: Utiliza un pool de conexiones para reducir el overhead de establecer y cerrar conexiones a la base de datos para cada operación.</li>
</ul>
<h3 id="7-actualizaciones-de-hardware">7. Actualizaciones de Hardware</h3>
<ul>
<li><strong>Mejoras de Hardware</strong>: Aumentar los recursos de hardware (como la memoria RAM, CPU más rápida, o almacenamiento SSD) puede ofrecer mejoras significativas en el rendimiento.</li>
</ul>
<h3 id="8-análisis-y-monitorización">8. Análisis y Monitorización</h3>
<ul>
<li><strong>Profiling de Consultas</strong>: Utiliza herramientas de profiling para identificar cuellos de botella y consultas ineficientes.</li>
<li><strong>Monitorización</strong>: Implementa soluciones de monitorización para rastrear el rendimiento de la base de datos y identificar problemas en tiempo real.</li>
</ul>
<h3 id="conclusión-2">Conclusión</h3>
<p>La optimización del rendimiento de las bases de datos es un proceso continuo que implica ajustes tanto en el diseño como en las consultas. Combinando múltiples estrategias, es posible manejar eficientemente grandes volúmenes de datos y mantener el rendimiento de las aplicaciones en niveles óptimos. Es crucial evaluar el impacto de cada cambio, probar exhaustivamente y monitorizar el rendimiento de manera regular.</p>
<h2 id="ejemplo-de-la-sesión">Ejemplo de la Sesión</h2>
<p>Se han diseñado dos tablas para almacenar la información de frutas y sus últimos precios conocidos o esperados.</p>
<pre><code class="language-sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> frutas_info (
    id number,
    nombre <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,
    descripcion <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>),
    <span class="hljs-keyword">constraint</span> pk_frutas_info <span class="hljs-keyword">primary</span> key (id)
);

<span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> frutas_precio (
    id number,
    fruta_id number <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,
    precio <span class="hljs-type">float</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,
    fecha <span class="hljs-type">timestamp</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,
    <span class="hljs-keyword">constraint</span> pk_frutas_precio <span class="hljs-keyword">primary</span> key (id),
    <span class="hljs-keyword">constraint</span> fk_fruta_id <span class="hljs-keyword">foreign</span> key (fruta_id)
        <span class="hljs-keyword">references</span> frutas_info (id)
);
</code></pre>
<p>La estructura proporcionada define dos tablas destinadas a almacenar información sobre frutas y sus precios a lo largo del tiempo. Vamos a desglosar cada una de estas tablas y su propósito, así como la relación entre ellas.</p>
<h3 id="tabla-frutas_info">Tabla <code>frutas_info</code></h3>
<p>Esta tabla está diseñada para almacenar información básica sobre diferentes tipos de frutas. Cada fruta tiene un <code>id</code> único, un <code>nombre</code>, y una <code>descripcion</code> opcional.</p>
<ul>
<li><strong>id</strong>: Es un campo numérico que actúa como clave primaria (<code>PRIMARY KEY</code>) de la tabla. Esto significa que cada valor en esta columna debe ser único y no nulo, identificando de manera unívoca a cada registro de fruta en la tabla.</li>
<li><strong>nombre</strong>: Un campo de texto (<code>VARCHAR</code>) que almacena el nombre de la fruta. Este campo es obligatorio (<code>NOT NULL</code>), lo que significa que cada fruta debe tener un nombre.</li>
<li><strong>descripcion</strong>: Un campo de texto opcional (<code>VARCHAR</code>) que puede usarse para almacenar una descripción adicional de la fruta.</li>
</ul>
<p>La restricción <code>PRIMARY KEY</code> asegura que el <code>id</code> de cada fruta sea único e identifique claramente cada fila.</p>
<h3 id="tabla-frutas_precio">Tabla <code>frutas_precio</code></h3>
<p>Esta tabla está destinada a almacenar información sobre los precios de las frutas a lo largo del tiempo, permitiendo registrar múltiples precios para la misma fruta en diferentes fechas.</p>
<ul>
<li><strong>id</strong>: Un campo numérico que sirve como clave primaria de la tabla, asegurando que cada registro de precio sea único.</li>
<li><strong>fruta_id</strong>: Este campo numérico establece una relación con la tabla <code>frutas_info</code>, especificando la fruta a la que se refiere el precio. La restricción <code>NOT NULL</code> garantiza que cada precio registrado esté vinculado a una fruta.</li>
<li><strong>precio</strong>: Un campo de tipo <code>FLOAT</code> para almacenar el precio de la fruta. Es un campo obligatorio.</li>
<li><strong>fecha</strong>: Un campo de tipo <code>TIMESTAMP</code> que registra la fecha y hora exacta en que se marcó el precio. También es obligatorio.</li>
</ul>
<p>Las restricciones definidas en la tabla son:</p>
<ul>
<li><strong>PRIMARY KEY (<code>pk_frutas_precio</code>)</strong>: Asegura que el <code>id</code> de cada registro de precio sea único.</li>
<li><strong>FOREIGN KEY (<code>fk_fruta_id</code>)</strong>: Establece una relación de clave foránea con la columna <code>id</code> de la tabla <code>frutas_info</code>, asegurando que cada <code>fruta_id</code> en <code>frutas_precio</code> corresponda a un <code>id</code> válido en <code>frutas_info</code>. Esto mantiene la integridad referencial entre las tablas, lo que significa que no puedes tener un precio referenciado a una fruta que no exista en la tabla <code>frutas_info</code>.</li>
</ul>
<h3 id="relación-entre-las-tablas">Relación entre las Tablas</h3>
<p>La relación establecida por la clave foránea (<code>FOREIGN KEY</code>) permite que la base de datos mantenga la integridad de los datos entre las dos tablas. Por ejemplo, no podrás insertar un registro en <code>frutas_precio</code> que haga referencia a una <code>fruta_id</code> que no exista en <code>frutas_info</code>, y si intentas eliminar una fruta de <code>frutas_info</code> que ya tiene precios asociados en <code>frutas_precio</code>, la operación será rechazada a menos que se manejen adecuadamente las dependencias (por ejemplo, borrando primero los registros de precios relacionados o utilizando políticas de borrado en cascada, si el DBMS lo permite).</p>
<p>Este diseño permite un almacenamiento eficiente de los datos, donde la información fundamental de cada fruta se almacena una sola vez en <code>frutas_info</code>, mientras que <code>frutas_precio</code> puede contener múltiples registros de precios para cada fruta a lo largo del tiempo, capturando la evolución del precio de cada fruta.</p>
<h3 id="inserción-de-datos">Inserción de datos</h3>
<p>Se insertaron datos mediante la consulta <code>INSERT</code> para proveer una lista inicial de frutas y sus precios conocidos:</p>
<pre><code class="language-sql"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> frutas_info (id, nombre, descripcion) <span class="hljs-keyword">values</span> (<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;Manzana Golden&#x27;</span>, <span class="hljs-string">&#x27;Manzana de piel amarilla brillante, dulce y crujiente.&#x27;</span>);
<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> frutas_info (id, nombre, descripcion) <span class="hljs-keyword">values</span> (<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;Pera Bartlett&#x27;</span>, <span class="hljs-string">&#x27;Pera jugosa y dulce, de piel suave y color verde que se torna amarillo al madurar.&#x27;</span>);
<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> frutas_info (id, nombre, descripcion) <span class="hljs-keyword">values</span> (<span class="hljs-number">3</span>, <span class="hljs-string">&#x27;Plátano Cavendish&#x27;</span>, <span class="hljs-string">&#x27;Variedad de plátano más común, grande y curvado con piel firme.&#x27;</span>);
<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> frutas_info (id, nombre, descripcion) <span class="hljs-keyword">values</span> (<span class="hljs-number">4</span>, <span class="hljs-string">&#x27;Naranja Navel&#x27;</span>, <span class="hljs-string">&#x27;Naranja grande y dulce sin semillas, ideal para comer o hacer jugo.&#x27;</span>);
<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> frutas_info (id, nombre, descripcion) <span class="hljs-keyword">values</span> (<span class="hljs-number">5</span>, <span class="hljs-string">&#x27;Piña Miel&#x27;</span>, <span class="hljs-string">&#x27;Piña grande y jugosa, sabor a miel.&#x27;</span>);
<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> frutas_info (id, nombre, descripcion) <span class="hljs-keyword">values</span> (<span class="hljs-number">6</span>, <span class="hljs-string">&#x27;Uva Crimson&#x27;</span>, <span class="hljs-string">&#x27;Uva de piel roja, sin semillas, crujiente y muy dulce.&#x27;</span>);

<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> frutas_precio (id, fruta_id, precio, fecha) <span class="hljs-keyword">values</span> (<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">45.67</span>, <span class="hljs-built_in">CURRENT_TIMESTAMP</span>);
<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> frutas_precio (id, fruta_id, precio, fecha) <span class="hljs-keyword">values</span> (<span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">48.98</span>, TO_TIMESTAMP_TZ(<span class="hljs-string">&#x27;2024-05-01 12:00:00 America/Mexico_City&#x27;</span>, <span class="hljs-string">&#x27;YYYY-MM-DD HH24:MI:SS TZR&#x27;</span>));
<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> frutas_precio (id, fruta_id, precio, fecha) <span class="hljs-keyword">values</span> (<span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">43.12</span>, TO_TIMESTAMP_TZ(<span class="hljs-string">&#x27;2024-05-15 13:00:00 America/Mexico_City&#x27;</span>, <span class="hljs-string">&#x27;YYYY-MM-DD HH24:MI:SS TZR&#x27;</span>));
<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> frutas_precio (id, fruta_id, precio, fecha) <span class="hljs-keyword">values</span> (<span class="hljs-number">4</span>, <span class="hljs-number">2</span>, <span class="hljs-number">41.45</span>, TO_TIMESTAMP_TZ(<span class="hljs-string">&#x27;2024-04-01 12:00:00 America/Mexico_City&#x27;</span>, <span class="hljs-string">&#x27;YYYY-MM-DD HH24:MI:SS TZR&#x27;</span>));
<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> frutas_precio (id, fruta_id, precio, fecha) <span class="hljs-keyword">values</span> (<span class="hljs-number">5</span>, <span class="hljs-number">3</span>, <span class="hljs-number">25.32</span>, <span class="hljs-built_in">CURRENT_TIMESTAMP</span>);
<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> frutas_precio (id, fruta_id, precio, fecha) <span class="hljs-keyword">values</span> (<span class="hljs-number">6</span>, <span class="hljs-number">4</span>, <span class="hljs-number">15.56</span>, TO_TIMESTAMP_TZ(<span class="hljs-string">&#x27;2024-04-03 17:30:00 America/Mexico_City&#x27;</span>, <span class="hljs-string">&#x27;YYYY-MM-DD HH24:MI:SS TZR&#x27;</span>));
<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> frutas_precio (id, fruta_id, precio, fecha) <span class="hljs-keyword">values</span> (<span class="hljs-number">7</span>, <span class="hljs-number">4</span>, <span class="hljs-number">18.82</span>, <span class="hljs-built_in">CURRENT_TIMESTAMP</span>);
<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> frutas_precio (id, fruta_id, precio, fecha) <span class="hljs-keyword">values</span> (<span class="hljs-number">8</span>, <span class="hljs-number">5</span>, <span class="hljs-number">78.98</span>, <span class="hljs-built_in">CURRENT_TIMESTAMP</span>);
<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> frutas_precio (id, fruta_id, precio, fecha) <span class="hljs-keyword">values</span> (<span class="hljs-number">9</span>, <span class="hljs-number">5</span>, <span class="hljs-number">89.22</span>, TO_TIMESTAMP_TZ(<span class="hljs-string">&#x27;2024-06-03 17:30:00 America/Mexico_City&#x27;</span>, <span class="hljs-string">&#x27;YYYY-MM-DD HH24:MI:SS TZR&#x27;</span>));
</code></pre>
<p>Las consultas proporcionadas son instrucciones <code>INSERT</code> que añaden registros a dos tablas relacionadas, <code>frutas_info</code> y <code>frutas_precio</code>. Vamos a desglosar el propósito y la función de estas consultas.</p>
<h3 id="consultas-para-frutas_info">Consultas para <code>frutas_info</code></h3>
<p>Estas consultas insertan registros en la tabla <code>frutas_info</code>, que está diseñada para almacenar información básica sobre diferentes tipos de frutas. Cada registro incluye un <code>id</code> único, un <code>nombre</code> para la fruta y una <code>descripcion</code> detallada de la misma.</p>
<pre><code class="language-sql"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> frutas_info (id, nombre, descripcion) <span class="hljs-keyword">values</span> (<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;Manzana Golden&#x27;</span>, <span class="hljs-string">&#x27;Manzana de piel amarilla brillante, dulce y crujiente.&#x27;</span>);
...
<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> frutas_info (id, nombre, descripcion) <span class="hljs-keyword">values</span> (<span class="hljs-number">6</span>, <span class="hljs-string">&#x27;Uva Crimson&#x27;</span>, <span class="hljs-string">&#x27;Uva de piel roja, sin semillas, crujiente y muy dulce.&#x27;</span>);
</code></pre>
<p>Cada fila representa un tipo de fruta distinto, con descripciones que ayudan a identificar sus características únicas. Por ejemplo, la <code>Manzana Golden</code> se describe como una manzana de &quot;piel amarilla brillante, dulce y crujiente&quot;.</p>
<h3 id="consultas-para-frutas_precio">Consultas para <code>frutas_precio</code></h3>
<p>Estas consultas insertan registros en la tabla <code>frutas_precio</code>, que almacena información sobre los precios de las frutas registradas en <code>frutas_info</code> en diferentes momentos. Cada registro incluye un <code>id</code> único, un <code>fruta_id</code> que vincula el precio a una fruta específica en <code>frutas_info</code>, un <code>precio</code> y una <code>fecha</code> que indica cuándo se registró ese precio.</p>
<pre><code class="language-sql"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> frutas_precio (id, fruta_id, precio, fecha) <span class="hljs-keyword">values</span> (<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">45.67</span>, <span class="hljs-built_in">CURRENT_TIMESTAMP</span>);
...
<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> frutas_precio (id, fruta_id, precio, fecha) <span class="hljs-keyword">values</span> (<span class="hljs-number">9</span>, <span class="hljs-number">5</span>, <span class="hljs-number">89.22</span>, TO_TIMESTAMP_TZ(<span class="hljs-string">&#x27;2024-06-03 17:30:00 America/Mexico_City&#x27;</span>, <span class="hljs-string">&#x27;YYYY-MM-DD HH24:MI:SS TZR&#x27;</span>));
</code></pre>
<p>Los precios se registran con timestamps precisos. En algunas consultas se utiliza <code>CURRENT_TIMESTAMP</code> para registrar el precio con el timestamp actual del sistema. En otros casos, se utiliza <code>TO_TIMESTAMP_TZ</code> para especificar manualmente la fecha y hora, incluyendo la zona horaria (por ejemplo, <code>'2024-05-01 12:00:00 America/Mexico_City'</code>), lo cual es útil para garantizar la precisión en ambientes distribuidos geográficamente o para registrar precios históricos.</p>
<h3 id="propósito-y-relación">Propósito y Relación</h3>
<ul>
<li>
<p><strong>Propósito</strong>: La inserción de datos en estas tablas permite a una aplicación rastrear no solo qué frutas están disponibles sino también cómo cambian sus precios con el tiempo. Esto puede ser fundamental para aplicaciones en negocios de venta al detalle, análisis de mercado, o sistemas de inventario.</p>
</li>
<li>
<p><strong>Relación</strong>: La clave <code>fruta_id</code> en <code>frutas_precio</code> establece una relación de clave foránea con la clave primaria <code>id</code> en <code>frutas_info</code>. Esto asegura que cada precio registrado en <code>frutas_precio</code> esté asociado con una fruta específica en <code>frutas_info</code>, manteniendo la integridad referencial entre las tablas.</p>
</li>
</ul>
<p>Este diseño de base de datos permite consultas complejas, como determinar el último precio de una fruta específica, visualizar la historia de precios de una fruta, o comparar precios entre diferentes frutas en fechas específicas, todo mientras se mantiene organizada y accesible la información básica de las frutas.</p>
<h3 id="consulta-de-datos">Consulta de datos</h3>
<p>Se diseñaron las siguientes consultas para reportar la relación entre la información de las frutas y sus precios:</p>
<pre><code class="language-sql"><span class="hljs-comment">-- Consulta de la Información de las Frutas</span>

<span class="hljs-keyword">select</span> id, nombre, descripcion <span class="hljs-keyword">from</span> frutas_info;

<span class="hljs-comment">-- Consulta de los Precios de las Frutas</span>

<span class="hljs-keyword">select</span> id, fruta_id, precio, fecha <span class="hljs-keyword">from</span> frutas_precio;

<span class="hljs-comment">-- Consulta de los últimos precios conocidos de cada Fruta (Subconsulta en SELECT)</span>

<span class="hljs-keyword">select</span> 
    fi.id <span class="hljs-keyword">as</span> frutaId, 
    fi.nombre,
    (
        <span class="hljs-keyword">select</span> fp.precio 
        <span class="hljs-keyword">from</span> frutas_precio fp
        <span class="hljs-keyword">where</span> fp.fruta_id <span class="hljs-operator">=</span> fi.id
        <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> fp.fecha <span class="hljs-keyword">desc</span>
        <span class="hljs-keyword">fetch</span> <span class="hljs-keyword">first</span> <span class="hljs-number">1</span> <span class="hljs-type">row</span> <span class="hljs-keyword">only</span>
    ) <span class="hljs-keyword">as</span> precio
<span class="hljs-keyword">from</span> frutas_info fi;

<span class="hljs-comment">-- Consulta de los últimos precios conocidos de cada fruta hasta la fecha actual (Subconsulta en SELECT)</span>

<span class="hljs-keyword">select</span> 
    fi.id <span class="hljs-keyword">as</span> frutaId, 
    fi.nombre,
    (
        <span class="hljs-keyword">select</span> fp.precio 
        <span class="hljs-keyword">from</span> frutas_precio fp
        <span class="hljs-keyword">where</span> fp.fruta_id <span class="hljs-operator">=</span> fi.id <span class="hljs-keyword">and</span> fp.fecha <span class="hljs-operator">&lt;</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span>
        <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> fp.fecha <span class="hljs-keyword">desc</span>
        <span class="hljs-keyword">fetch</span> <span class="hljs-keyword">first</span> <span class="hljs-number">1</span> <span class="hljs-type">row</span> <span class="hljs-keyword">only</span>
    ) <span class="hljs-keyword">as</span> precio
<span class="hljs-keyword">from</span> frutas_info fi;

<span class="hljs-comment">-- Consulta de los últimos precios conocidos de cada fruta hasta la fecha actual (Subconsulta WITH con Consulta anidada JOIN)</span>

<span class="hljs-keyword">with</span> fp <span class="hljs-keyword">as</span> (
    <span class="hljs-keyword">select</span> 
        <span class="hljs-built_in">ROW_NUMBER</span>() <span class="hljs-keyword">over</span> (<span class="hljs-keyword">partition</span> <span class="hljs-keyword">by</span> fruta_id <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> fecha <span class="hljs-keyword">desc</span>) <span class="hljs-keyword">as</span> rn,
        fruta_id,
        precio, 
        fecha
    <span class="hljs-keyword">from</span> frutas_precio
    <span class="hljs-keyword">where</span> fecha <span class="hljs-operator">&lt;</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span>
)
<span class="hljs-keyword">select</span> 
    fi.id <span class="hljs-keyword">as</span> frutaId, 
    fi.nombre,
    fp.precio,
    fp.fecha
<span class="hljs-keyword">from</span> frutas_info fi 
<span class="hljs-keyword">left</span> <span class="hljs-keyword">join</span> fp <span class="hljs-keyword">on</span> fp.fruta_id <span class="hljs-operator">=</span> fi.id <span class="hljs-keyword">and</span> rn <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;

<span class="hljs-comment">-- Consulta de los precios conocidos para las frutas (Consulta anidada JOIN)</span>

<span class="hljs-keyword">select</span> fp.id, fi.nombre, fp.precio, fp.fecha <span class="hljs-keyword">from</span> frutas_precio fp
    <span class="hljs-keyword">join</span> frutas_info fi <span class="hljs-keyword">on</span> fp.fruta_id <span class="hljs-operator">=</span> fi.id;

<span class="hljs-comment">-- Consulta de los precios conocidos para las frutas (Consulta anidada JOIN) </span>
<span class="hljs-comment">-- con Subconsulta para el último precio más reciente a la fecha actual</span>

<span class="hljs-keyword">select</span>
    fr.id,
    fr.nombre,
    fr.precio,
    fr.fecha
<span class="hljs-keyword">from</span> (
    <span class="hljs-keyword">select</span> 
        fp.id, 
        fi.nombre, 
        fp.precio, 
        fp.fecha,
        <span class="hljs-built_in">ROW_NUMBER</span>() <span class="hljs-keyword">over</span> (<span class="hljs-keyword">partition</span> <span class="hljs-keyword">by</span> fi.id <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> fp.fecha <span class="hljs-keyword">desc</span>) <span class="hljs-keyword">AS</span> rn
    <span class="hljs-keyword">from</span> frutas_precio fp
    <span class="hljs-keyword">left</span> <span class="hljs-keyword">join</span> frutas_info fi <span class="hljs-keyword">on</span> fp.fruta_id <span class="hljs-operator">=</span> fi.id
    <span class="hljs-keyword">where</span> fp.fecha <span class="hljs-operator">&lt;</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span>
) fr
<span class="hljs-keyword">where</span> fr.rn <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;
</code></pre>
<p>Estas consultas SQL se enfocan en extraer y manipular datos de dos tablas relacionadas: <code>frutas_info</code>, que almacena información general sobre frutas, y <code>frutas_precio</code>, que registra los precios de estas frutas a lo largo del tiempo. Vamos a desglosar cada consulta para entender su propósito y cómo funciona.</p>
<h3 id="consulta-de-la-información-de-las-frutas">Consulta de la Información de las Frutas</h3>
<pre><code class="language-sql"><span class="hljs-keyword">select</span> id, nombre, descripcion <span class="hljs-keyword">from</span> frutas_info;
</code></pre>
<p>Esta consulta selecciona todas las filas de la tabla <code>frutas_info</code>, devolviendo los <code>id</code>, <code>nombre</code> y <code>descripcion</code> de todas las frutas. Es una consulta básica que proporciona un resumen de todas las frutas disponibles.</p>
<h3 id="consulta-de-los-precios-de-las-frutas">Consulta de los Precios de las Frutas</h3>
<pre><code class="language-sql"><span class="hljs-keyword">select</span> id, fruta_id, precio, fecha <span class="hljs-keyword">from</span> frutas_precio;
</code></pre>
<p>Similar a la consulta anterior, pero para la tabla <code>frutas_precio</code>, recuperando todos los registros de precios de las frutas, incluyendo el <code>id</code> del registro de precio, <code>fruta_id</code> (que enlaza con <code>frutas_info</code>), <code>precio</code>, y la <code>fecha</code> en que se registró dicho precio.</p>
<h3 id="consulta-de-los-últimos-precios-conocidos-de-cada-fruta">Consulta de los Últimos Precios Conocidos de Cada Fruta</h3>
<pre><code class="language-sql"><span class="hljs-keyword">select</span> 
    fi.id <span class="hljs-keyword">as</span> frutaId, 
    fi.nombre,
    (
        <span class="hljs-keyword">select</span> fp.precio 
        <span class="hljs-keyword">from</span> frutas_precio fp
        <span class="hljs-keyword">where</span> fp.fruta_id <span class="hljs-operator">=</span> fi.id
        <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> fp.fecha <span class="hljs-keyword">desc</span>
        <span class="hljs-keyword">fetch</span> <span class="hljs-keyword">first</span> <span class="hljs-number">1</span> <span class="hljs-type">row</span> <span class="hljs-keyword">only</span>
    ) <span class="hljs-keyword">as</span> precio
<span class="hljs-keyword">from</span> frutas_info fi;
</code></pre>
<p>Esta consulta muestra el último precio conocido de cada fruta. Usa una subconsulta en la lista de selección para encontrar el último precio de cada fruta, ordenando los resultados por fecha de manera descendente y limitando a la primera fila (<code>fetch first 1 row only</code>), lo cual asegura que solo se devuelva el precio más reciente.</p>
<h3 id="consulta-de-los-últimos-precios-conocidos-hasta-la-fecha-actual">Consulta de los Últimos Precios Conocidos Hasta la Fecha Actual</h3>
<pre><code class="language-sql"><span class="hljs-keyword">select</span> 
    fi.id <span class="hljs-keyword">as</span> frutaId, 
    fi.nombre,
    (
        <span class="hljs-keyword">select</span> fp.precio 
        <span class="hljs-keyword">from</span> frutas_precio fp
        <span class="hljs-keyword">where</span> fp.fruta_id <span class="hljs-operator">=</span> fi.id <span class="hljs-keyword">and</span> fp.fecha <span class="hljs-operator">&lt;</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span>
        <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> fp.fecha <span class="hljs-keyword">desc</span>
        <span class="hljs-keyword">fetch</span> <span class="hljs-keyword">first</span> <span class="hljs-number">1</span> <span class="hljs-type">row</span> <span class="hljs-keyword">only</span>
    ) <span class="hljs-keyword">as</span> precio
<span class="hljs-keyword">from</span> frutas_info fi;
</code></pre>
<p>Es similar a la consulta anterior pero con una condición adicional que asegura que solo se consideren los precios registrados hasta el momento actual (<code>CURRENT_TIMESTAMP</code>), excluyendo así cualquier precio futuro que pudiera haberse registrado anticipadamente.</p>
<h3 id="consulta-de-los-últimos-precios-conocidos-con-with">Consulta de los Últimos Precios Conocidos con <code>WITH</code></h3>
<pre><code class="language-sql"><span class="hljs-keyword">with</span> fp <span class="hljs-keyword">as</span> (
    <span class="hljs-keyword">select</span> 
        <span class="hljs-built_in">ROW_NUMBER</span>() <span class="hljs-keyword">over</span> (<span class="hljs-keyword">partition</span> <span class="hljs-keyword">by</span> fruta_id <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> fecha <span class="hljs-keyword">desc</span>) <span class="hljs-keyword">as</span> rn,
        fruta_id,
        precio, 
        fecha
    <span class="hljs-keyword">from</span> frutas_precio
    <span class="hljs-keyword">where</span> fecha <span class="hljs-operator">&lt;</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span>
)
<span class="hljs-keyword">select</span> 
    fi.id <span class="hljs-keyword">as</span> frutaId, 
    fi.nombre,
    fp.precio,
    fp.fecha
<span class="hljs-keyword">from</span> frutas_info fi 
<span class="hljs-keyword">left</span> <span class="hljs-keyword">join</span> fp <span class="hljs-keyword">on</span> fp.fruta_id <span class="hljs-operator">=</span> fi.id <span class="hljs-keyword">and</span> rn <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;
</code></pre>
<p>Esta consulta usa una expresión de tabla común (<code>WITH</code>) para numerar los precios de cada fruta por su fecha, en orden descendente, y luego selecciona solo el precio más reciente (<code>rn = 1</code>). Es una forma más avanzada y posiblemente más eficiente de lograr el mismo resultado que las subconsultas anidadas anteriores, especialmente para conjuntos de datos grandes.</p>
<h3 id="consulta-de-los-precios-conocidos-para-las-frutas">Consulta de los Precios Conocidos para las Frutas</h3>
<pre><code class="language-sql"><span class="hljs-keyword">select</span> fp.id, fi.nombre, fp.precio, fp.fecha <span class="hljs-keyword">from</span> frutas_precio fp
    <span class="hljs-keyword">join</span> frutas_info fi <span class="hljs-keyword">on</span> fp.fruta_id <span class="hljs-operator">=</span> fi.id;
</code></pre>
<p>Esta consulta une <code>frutas_precio</code> con <code>frutas_info</code> para devolver una lista de todos los precios conocidos para las frutas, incluyendo el <code>nombre</code> de la fruta de la tabla <code>frutas_info</code>.</p>
<h3 id="consulta-de-precios-con-el-último-precio-más-reciente">Consulta de Precios con el Último Precio Más Reciente</h3>
<pre><code class="language-sql"><span class="hljs-keyword">select</span>
    fr.id,
    fr.nombre,
    fr.precio,
    fr.fecha
<span class="hljs-keyword">from</span> (
    <span class="hljs-keyword">select</span> 
        fp.id, 
        fi.nombre, 
        fp.precio, 
        fp.fecha,
        <span class="hljs-built_in">ROW_NUMBER</span>() <span class="hljs-keyword">over</span> (<span class="hljs-keyword">partition</span> <span class="hljs-keyword">by</span> fi.id <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> fp.fecha <span class="hljs-keyword">desc</span>) <span class="hljs-keyword">AS</span> rn
    <span class="hljs-keyword">from</span> frutas_precio fp
    <span class="hljs-keyword">left</span> <span class="hljs-keyword">join</span> frutas_info fi <span class="hljs-keyword">on</span> fp.fruta_id <span class="hljs-operator">=</span> fi.id
    <span class="hljs-keyword">where</span> fp.fecha <span class="hljs-operator">&lt;</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span>
) fr
<span class="hljs-keyword">where</span> fr.rn <span class="hljs-operator">=</span> <span class="hljs-number">1</span>

;
</code></pre>
<p>Esta consulta es una variante de las consultas anteriores que también utiliza la función de ventana <code>ROW_NUMBER()</code> para asignar un número de fila a cada precio de fruta, ordenado por fecha de manera descendente. Luego, selecciona solo la fila con el número 1 (<code>rn = 1</code>) para cada fruta, es decir, su último precio registrado hasta la fecha actual.</p>
<p>Todas estas consultas demuestran distintas técnicas para manipular y recuperar datos relacionados de manera eficiente en un sistema de base de datos, utilizando tanto métodos simples como avanzados para satisfacer requerimientos específicos de información.</p>

            
            
        </body>
        </html>