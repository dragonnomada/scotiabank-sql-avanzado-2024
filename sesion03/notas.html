<!DOCTYPE html>
<html>
<head>
<title>notas.md</title>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">

<style>
/* https://github.com/microsoft/vscode/blob/master/extensions/markdown-language-features/media/markdown.css */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: var(--vscode-markdown-font-family, -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif);
	font-size: var(--vscode-markdown-font-size, 14px);
	padding: 0 26px;
	line-height: var(--vscode-markdown-line-height, 22px);
	word-wrap: break-word;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}

body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-light.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-dark.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

.vscode-high-contrast.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	text-decoration: none;
}

a:hover {
	text-decoration: underline;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left-width: 5px;
	border-left-style: solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 1em;
	line-height: 1.357em;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

pre code {
	color: var(--vscode-editor-foreground);
	tab-size: 4;
}

/** Theming */

.vscode-light pre {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

</style>

<style>
/* Tomorrow Theme */
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
/* Original theme - https://github.com/chriskempson/tomorrow-theme */

/* Tomorrow Comment */
.hljs-comment,
.hljs-quote {
	color: #8e908c;
}

/* Tomorrow Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-deletion {
	color: #c82829;
}

/* Tomorrow Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-meta,
.hljs-link {
	color: #f5871f;
}

/* Tomorrow Yellow */
.hljs-attribute {
	color: #eab700;
}

/* Tomorrow Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
	color: #718c00;
}

/* Tomorrow Blue */
.hljs-title,
.hljs-section {
	color: #4271ae;
}

/* Tomorrow Purple */
.hljs-keyword,
.hljs-selector-tag {
	color: #8959a8;
}

.hljs {
	display: block;
	overflow-x: auto;
	color: #4d4d4c;
	padding: 0.5em;
}

.hljs-emphasis {
	font-style: italic;
}

.hljs-strong {
	font-weight: bold;
}
</style>

<style>
/*
 * Markdown PDF CSS
 */

 body {
	font-family: -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif, "Meiryo";
	padding: 0 12px;
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

code {
	font-size: 14px;
	line-height: 19px;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #C9AE75; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

</style>

<script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script>
</head>
<body>
  <script>
    mermaid.initialize({
      startOnLoad: true,
      theme: document.body.classList.contains('vscode-dark') || document.body.classList.contains('vscode-high-contrast')
          ? 'dark'
          : 'default'
    });
  </script>
<h1 id="curso-de-sql-avanzado---sesi%C3%B3n-3">Curso de SQL Avanzado - Sesión 3</h1>
<img src="https://amei.mx/wp-content/uploads/2016/08/Scotiabank-logo.jpg" alt="Scotiabank Logo" height="60">
<img src="https://www.belatrix.com/wp-content/uploads/2023/08/belatrix-logosweb-1.png" alt="Belatrix Logo" height="60">
<p><strong><a href="https://www.scotiabank.com.mx">Scotiabank</a></strong> | <strong><a href="https://www.belatrix.com">Belatrix</a></strong></p>
<p>Instructor: <a href="alan@nomadacode.com">Alan Badillo Salas</a></p>
<hr>
<h2 id="contenido">Contenido</h2>
<pre><code>Módulo 3: Modelado de Datos Avanzado

1. Normalización y desnormalización
2. Diseño de esquemas avanzados
3. Estrategias de particionamiento
</code></pre>
<h3 id="temas">Temas</h3>
<ol start="301">
<li>Normalización y desnormalización</li>
<li>Diseño de esquemas avanzados</li>
<li>Estrategias de particionamiento</li>
</ol>
<h2 id="301-normalizaci%C3%B3n-y-desnormalizaci%C3%B3n">301. Normalización y desnormalización</h2>
<p>La normalización y desnormalización son conceptos fundamentales en el diseño de bases de datos relacionales, y juegan roles cruciales en cómo se estructuran y acceden a los datos. Ambos enfoques buscan optimizar la base de datos, pero desde perspectivas diferentes. Vamos a explorar ambos.</p>
<h3 id="normalizaci%C3%B3n">Normalización</h3>
<p>La normalización es el proceso de estructurar una base de datos relacional para reducir la redundancia de datos y mejorar la integridad de estos. Esto se logra mediante la organización de los datos en tablas de manera que se minimicen las dependencias, se evite la duplicación de datos, y se facilite el mantenimiento y la actualización de la base de datos. El proceso de normalización se lleva a cabo a través de varias &quot;formas normales&quot; (1NF, 2NF, 3NF, BCNF, 4NF, etc.), cada una con requisitos más estrictos que la anterior.</p>
<ul>
<li><strong>Primera forma normal (1NF):</strong> Asegura que cada columna en una tabla sea atómica y que la tabla tenga una clave única.</li>
<li><strong>Segunda forma normal (2NF):</strong> Requiere que la tabla esté en 1NF y que todos los atributos no clave dependan completamente de la clave primaria.</li>
<li><strong>Tercera forma normal (3NF):</strong> Se alcanza cuando una tabla está en 2NF y todos sus campos no clave son dependientes solo de la clave primaria, eliminando así las dependencias transitivas.</li>
<li><strong>Forma normal de Boyce-Codd (BCNF):</strong> Una versión más estricta de la 3NF, donde cada determinante es una clave candidata.</li>
<li><strong>Cuarta forma normal (4NF):</strong> Asegura que las relaciones multivaluadas se identifiquen y se separen en sus propias tablas.</li>
</ul>
<p>La normalización mejora la consistencia y la integridad de los datos, facilita el diseño de bases de datos y reduce la posibilidad de anomalías de datos. Sin embargo, puede llevar a un mayor número de tablas, lo que puede complicar las consultas y afectar el rendimiento.</p>
<h3 id="desnormalizaci%C3%B3n">Desnormalización</h3>
<p>La desnormalización es el proceso de estructurar una base de datos relacional para mejorar el rendimiento de lectura de la base de datos, a expensas de introducir cierta redundancia de datos y complicar la actualización de los datos. Esto se hace típicamente agregando datos redundantes o agrupando datos en tablas más grandes para reducir el número de uniones necesarias en las consultas.</p>
<p>La desnormalización es útil en escenarios donde las operaciones de lectura son mucho más frecuentes que las operaciones de escritura, y donde el rendimiento de las consultas es crítico. Algunas técnicas de desnormalización incluyen:</p>
<ul>
<li><strong>Agregar columnas redundantes</strong> para evitar cálculos costosos o uniones.</li>
<li><strong>Combinar tablas</strong> que se consultan juntas con frecuencia.</li>
<li><strong>Utilizar tablas de resumen</strong> para consultas agregadas frecuentes.</li>
</ul>
<p>La desnormalización debe hacerse con cuidado, ya que la introducción de redundancia puede llevar a anomalías de datos y complicar el mantenimiento de la base de datos.</p>
<h3 id="conclusi%C3%B3n">Conclusión</h3>
<p>La normalización y desnormalización no son mutuamente excluyentes y a menudo se utilizan juntas en el diseño de bases de datos. La clave es encontrar el equilibrio adecuado que satisfaga los requisitos de integridad y rendimiento de la aplicación. En ambientes como Oracle, estos conceptos son esenciales para aprovechar al máximo las capacidades avanzadas del sistema de gestión de bases de datos, optimizando así tanto el almacenamiento como el acceso a los datos.</p>
<h3 id="ejemplo-de-una-tabla-en-la-primera-forma-normal-1nf">Ejemplo de una tabla en la Primera Forma Normal (1NF)</h3>
<p>Vamos a comenzar con un ejemplo básico de una tabla que no cumple con la Primera Forma Normal (1NF) y luego cómo transformarla para que sí cumpla.</p>
<h3 id="tabla-no-normalizada">Tabla No Normalizada</h3>
<p>Imagina que tenemos una tabla que registra ventas de productos en una tienda, pero esta tabla no está en 1NF porque algunos de los campos contienen grupos de valores, lo cual viola una de las reglas de 1NF donde cada campo debe contener valores atómicos (indivisibles).</p>
<p><strong>Tabla de Ventas (No en 1NF):</strong></p>
<table>
<thead>
<tr>
<th>VentaID</th>
<th>Cliente</th>
<th>Productos</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>Juan Pérez</td>
<td>Televisor, Lavadora</td>
</tr>
<tr>
<td>2</td>
<td>Ana Gómez</td>
<td>Refrigerador</td>
</tr>
<tr>
<td>3</td>
<td>Luis Méndez</td>
<td>Licuadora, Tostadora</td>
</tr>
</tbody>
</table>
<p>En esta tabla, el campo <code>Productos</code> no es atómico porque lista más de un producto para algunas ventas.</p>
<h3 id="transformaci%C3%B3n-a-1nf">Transformación a 1NF</h3>
<p>Para transformar esta tabla a la Primera Forma Normal, necesitamos asegurarnos de que cada campo contenga solo valores atómicos. Esto implica descomponer el campo <code>Productos</code> para que cada producto esté en su propia fila. Además, asegurarse de que la tabla tenga una clave única puede requerir agregar un nuevo campo (por ejemplo, <code>DetalleVentaID</code>) si es necesario para mantener la unicidad de cada fila.</p>
<p><strong>Tabla de Ventas Detallada (En 1NF):</strong></p>
<table>
<thead>
<tr>
<th>DetalleVentaID</th>
<th>VentaID</th>
<th>Cliente</th>
<th>Producto</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>1</td>
<td>Juan Pérez</td>
<td>Televisor</td>
</tr>
<tr>
<td>2</td>
<td>1</td>
<td>Juan Pérez</td>
<td>Lavadora</td>
</tr>
<tr>
<td>3</td>
<td>2</td>
<td>Ana Gómez</td>
<td>Refrigerador</td>
</tr>
<tr>
<td>4</td>
<td>3</td>
<td>Luis Méndez</td>
<td>Licuadora</td>
</tr>
<tr>
<td>5</td>
<td>3</td>
<td>Luis Méndez</td>
<td>Tostadora</td>
</tr>
</tbody>
</table>
<p>En esta versión normalizada de la tabla:</p>
<ul>
<li>Cada fila tiene una clave única (<code>DetalleVentaID</code>).</li>
<li>Cada campo (columna) contiene solo valores atómicos, cumpliendo con la definición de 1NF.</li>
<li>La relación entre <code>VentaID</code> y <code>Cliente</code> se repite para cada producto involucrado en la misma venta, lo que es aceptable y necesario en este diseño para mantener la relación entre ventas y productos.</li>
</ul>
<p>Esta estructura facilita la gestión de los datos y permite realizar consultas más precisas y eficientes, como buscar todos los productos que compró un cliente específico o todas las ventas donde se vendió un producto específico.</p>
<h3 id="ejemplo-de-una-tabla-en-la-segunda-forma-normal-2nf">Ejemplo de una tabla en la Segunda Forma Normal (2NF)</h3>
<p>Para llevar una tabla a la Segunda Forma Normal (2NF), primero debe cumplir con la Primera Forma Normal (1NF), y además, debe asegurarse de que todos los atributos no clave dependan completamente de la clave primaria de la tabla. Esto significa que la tabla no debe tener dependencias parciales, es decir, ningún atributo debe depender solo de una parte de una clave primaria compuesta.</p>
<p>Vamos a usar el ejemplo de la tabla de ventas detallada de la sección anterior y transformarla para que cumpla con 2NF. La tabla ya está en 1NF, pero si consideramos <code>DetalleVentaID</code> como nuestra clave única, no hay dependencias parciales porque cada atributo no clave depende de toda la clave. Sin embargo, para ilustrar mejor el concepto de 2NF, supongamos que <code>VentaID</code> y <code>Producto</code> juntos forman una clave primaria compuesta en una nueva tabla que registra los detalles de los productos vendidos, pero ahora incluimos un nuevo campo <code>PrecioProducto</code>, que es dependiente de <code>Producto</code>, pero no de <code>VentaID</code>.</p>
<h3 id="tabla-detalleventas-casi-1nf-no-2nf-debido-a-dependencias-parciales">Tabla DetalleVentas (Casi 1NF, no 2NF debido a dependencias parciales)</h3>
<table>
<thead>
<tr>
<th>VentaID (PK)</th>
<th>Producto (PK)</th>
<th>Cliente</th>
<th>PrecioProducto</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>Televisor</td>
<td>Juan Pérez</td>
<td>800</td>
</tr>
<tr>
<td>1</td>
<td>Lavadora</td>
<td>Juan Pérez</td>
<td>400</td>
</tr>
<tr>
<td>2</td>
<td>Refrigerador</td>
<td>Ana Gómez</td>
<td>1000</td>
</tr>
<tr>
<td>3</td>
<td>Licuadora</td>
<td>Luis Méndez</td>
<td>150</td>
</tr>
<tr>
<td>3</td>
<td>Tostadora</td>
<td>Luis Méndez</td>
<td>100</td>
</tr>
</tbody>
</table>
<p>En esta tabla, <code>PrecioProducto</code> depende solo de <code>Producto</code> y no de <code>VentaID</code>, lo que representa una dependencia parcial respecto a la clave primaria compuesta (<code>VentaID</code>, <code>Producto</code>). Esto viola la 2NF.</p>
<h3 id="transformaci%C3%B3n-a-2nf">Transformación a 2NF</h3>
<p>Para corregir esto y llevar la tabla a 2NF, necesitamos eliminar las dependencias parciales dividiendo la tabla en dos: una tabla que capture la relación de ventas (incluyendo el cliente y la venta) y otra que capture los productos y sus precios. Así, cada tabla tiene claves primarias a las cuales todos los atributos no clave están completamente relacionados, eliminando las dependencias parciales.</p>
<p><strong>Tabla Ventas</strong></p>
<table>
<thead>
<tr>
<th>VentaID</th>
<th>Cliente</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>Juan Pérez</td>
</tr>
<tr>
<td>2</td>
<td>Ana Gómez</td>
</tr>
<tr>
<td>3</td>
<td>Luis Méndez</td>
</tr>
</tbody>
</table>
<p><strong>Tabla ProductosVendidos</strong></p>
<table>
<thead>
<tr>
<th>VentaID</th>
<th>Producto</th>
<th>PrecioProducto</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>Televisor</td>
<td>800</td>
</tr>
<tr>
<td>1</td>
<td>Lavadora</td>
<td>400</td>
</tr>
<tr>
<td>2</td>
<td>Refrigerador</td>
<td>1000</td>
</tr>
<tr>
<td>3</td>
<td>Licuadora</td>
<td>150</td>
</tr>
<tr>
<td>3</td>
<td>Tostadora</td>
<td>100</td>
</tr>
</tbody>
</table>
<p>En este diseño:</p>
<ul>
<li>La tabla <strong>Ventas</strong> tiene una clave primaria (<code>VentaID</code>) que identifica de forma única cada venta.</li>
<li>La tabla <strong>ProductosVendidos</strong> utiliza una clave compuesta (<code>VentaID</code>, <code>Producto</code>) para identificar de forma única cada producto vendido en cada venta. Aquí, <code>PrecioProducto</code> depende completamente de la clave primaria compuesta, satisfaciendo así los requisitos de 2NF.</li>
<li>Se eliminan las dependencias parciales, ya que ahora <code>PrecioProducto</code> está en una tabla donde depende completamente de la clave primaria.</li>
</ul>
<p>Este enfoque mejora la estructura de la base de datos al asegurar que todos los atributos en cada tabla dependan completamente de la clave primaria, facilitando la actualización de los datos y reduciendo la redundancia.</p>
<h3 id="ejemplo-de-una-tabla-en-la-tercera-forma-normal-3nf">Ejemplo de una tabla en la Tercera Forma Normal (3NF)</h3>
<p>Para alcanzar la Tercera Forma Normal (3NF), una tabla debe primero cumplir con la Segunda Forma Normal (2NF). Además, 3NF requiere que todos los atributos no clave sean mutuamente independientes entre sí y que solo dependan de la clave primaria. Esto significa que no debe haber dependencias transitivas, donde un atributo no clave dependa de otro atributo no clave.</p>
<p>Vamos a expandir el ejemplo de las tablas <strong>Ventas</strong> y <strong>ProductosVendidos</strong> para llevarlas a 3NF, suponiendo que hemos identificado una dependencia transitoria.</p>
<h3 id="tabla-productosvendidos-en-2nf-pero-con-una-dependencia-transitoria">Tabla ProductosVendidos (En 2NF, pero con una dependencia transitoria)</h3>
<p>Recordemos la tabla <strong>ProductosVendidos</strong>:</p>
<table>
<thead>
<tr>
<th>VentaID</th>
<th>Producto</th>
<th>PrecioProducto</th>
<th>CategoriaProducto</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>Televisor</td>
<td>800</td>
<td>Electrónica</td>
</tr>
<tr>
<td>1</td>
<td>Lavadora</td>
<td>400</td>
<td>Electrodomésticos</td>
</tr>
<tr>
<td>2</td>
<td>Refrigerador</td>
<td>1000</td>
<td>Electrodomésticos</td>
</tr>
<tr>
<td>3</td>
<td>Licuadora</td>
<td>150</td>
<td>Cocina</td>
</tr>
<tr>
<td>3</td>
<td>Tostadora</td>
<td>100</td>
<td>Cocina</td>
</tr>
</tbody>
</table>
<p>En esta versión, supongamos que hemos añadido <code>CategoriaProducto</code>, que es un atributo que depende de <code>Producto</code>, pero no de <code>VentaID</code>. Esto crea una dependencia transitoria, ya que <code>CategoriaProducto</code> depende indirectamente de la clave primaria (<code>VentaID</code>, <code>Producto</code>) a través de <code>Producto</code>. Este diseño viola 3NF porque <code>CategoriaProducto</code> no depende directamente de la clave primaria de la tabla.</p>
<h3 id="transformaci%C3%B3n-a-3nf">Transformación a 3NF</h3>
<p>Para corregir esto y llevar la tabla a 3NF, necesitamos eliminar las dependencias transitivas. Podemos hacerlo dividiendo la tabla en dos, de modo que <code>CategoriaProducto</code> esté en una tabla donde dependa directamente de una clave primaria.</p>
<p><strong>Tabla Productos</strong></p>
<table>
<thead>
<tr>
<th>Producto</th>
<th>CategoriaProducto</th>
</tr>
</thead>
<tbody>
<tr>
<td>Televisor</td>
<td>Electrónica</td>
</tr>
<tr>
<td>Lavadora</td>
<td>Electrodomésticos</td>
</tr>
<tr>
<td>Refrigerador</td>
<td>Electrodomésticos</td>
</tr>
<tr>
<td>Licuadora</td>
<td>Cocina</td>
</tr>
<tr>
<td>Tostadora</td>
<td>Cocina</td>
</tr>
</tbody>
</table>
<p><strong>Tabla ProductosVendidos Actualizada</strong></p>
<table>
<thead>
<tr>
<th>VentaID</th>
<th>Producto</th>
<th>PrecioProducto</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>Televisor</td>
<td>800</td>
</tr>
<tr>
<td>1</td>
<td>Lavadora</td>
<td>400</td>
</tr>
<tr>
<td>2</td>
<td>Refrigerador</td>
<td>1000</td>
</tr>
<tr>
<td>3</td>
<td>Licuadora</td>
<td>150</td>
</tr>
<tr>
<td>3</td>
<td>Tostadora</td>
<td>100</td>
</tr>
</tbody>
</table>
<p>En este diseño:</p>
<ul>
<li>La <strong>Tabla Productos</strong> contiene la <code>CategoriaProducto</code> y tiene <code>Producto</code> como clave primaria. Ahora cada producto está asociado con su categoría directamente, sin depender de la venta.</li>
<li>La <strong>Tabla ProductosVendidos</strong> se simplifica para contener solo la información específica de cada venta (precio y producto vendido), cumpliendo con 3NF. No hay dependencias transitivas porque todos los atributos no clave dependen únicamente de la clave primaria compuesta (<code>VentaID</code>, <code>Producto</code>).</li>
</ul>
<p>Este enfoque mejora la estructura de la base de datos eliminando dependencias innecesarias y redundancias, lo que facilita el mantenimiento y la actualización de los datos.</p>
<h3 id="ejemplo-de-una-tabla-en-la-forma-normal-de-boyce-codd-bcnf">Ejemplo de una tabla en la Forma Normal de Boyce-Codd (BCNF)</h3>
<p>La Forma Normal de Boyce-Codd (BCNF) es una versión más estricta de la Tercera Forma Normal (3NF). Una tabla está en BCNF si, y solo si, para cada una de sus dependencias funcionales no triviales, el lado izquierdo es una superclave. Esto significa que la tabla no debe tener dependencias funcionales no triviales de un conjunto de atributos a otro, a menos que ese conjunto de atributos sea una superclave, es decir, un conjunto de atributos que puede identificar de manera única una fila en la tabla.</p>
<p>Un problema común que BCNF busca resolver es el de las dependencias funcionales que involucran claves candidatas que no son parte de la clave primaria, algo que 3NF permite siempre y cuando no haya dependencias transitivas. Vamos a presentar un ejemplo simple que muestra cómo una tabla puede cumplir con 3NF pero no con BCNF, y luego cómo transformarla a BCNF.</p>
<h3 id="ejemplo-antes-de-bcnf">Ejemplo antes de BCNF</h3>
<p>Supongamos que tenemos una tabla que registra las asignaciones de aulas para clases en una universidad:</p>
<p><strong>Tabla AsignacionesAula (En 3NF, pero no en BCNF)</strong></p>
<table>
<thead>
<tr>
<th>AulaID</th>
<th>Profesor</th>
<th>Materia</th>
</tr>
</thead>
<tbody>
<tr>
<td>101</td>
<td>Ana Gómez</td>
<td>Matemáticas</td>
</tr>
<tr>
<td>102</td>
<td>Luis Pérez</td>
<td>Historia</td>
</tr>
<tr>
<td>103</td>
<td>Ana Gómez</td>
<td>Física</td>
</tr>
</tbody>
</table>
<p>En este caso, supongamos que cada profesor solo puede enseñar una materia específica, lo que introduce una dependencia funcional de <code>Profesor</code> a <code>Materia</code>. Esto significa que conociendo el <code>Profesor</code>, podemos determinar la <code>Materia</code>. Sin embargo, <code>Profesor</code> no es una superclave, ya que no puede identificar de manera única cada fila de la tabla (Ana Gómez enseña dos materias en diferentes aulas).</p>
<h3 id="transformaci%C3%B3n-a-bcnf">Transformación a BCNF</h3>
<p>Para resolver este problema y cumplir con BCNF, necesitamos dividir la tabla en dos de manera que todas las dependencias funcionales no triviales tengan una superclave como su lado izquierdo.</p>
<p><strong>Tabla ProfesoresMaterias</strong></p>
<table>
<thead>
<tr>
<th>Profesor</th>
<th>Materia</th>
</tr>
</thead>
<tbody>
<tr>
<td>Ana Gómez</td>
<td>Matemáticas</td>
</tr>
<tr>
<td>Luis Pérez</td>
<td>Historia</td>
</tr>
<tr>
<td>Ana Gómez</td>
<td>Física</td>
</tr>
</tbody>
</table>
<p><strong>Tabla AsignacionesAula Actualizada</strong></p>
<table>
<thead>
<tr>
<th>AulaID</th>
<th>Profesor</th>
</tr>
</thead>
<tbody>
<tr>
<td>101</td>
<td>Ana Gómez</td>
</tr>
<tr>
<td>102</td>
<td>Luis Pérez</td>
</tr>
<tr>
<td>103</td>
<td>Ana Gómez</td>
</tr>
</tbody>
</table>
<p>Ahora, en la <strong>Tabla ProfesoresMaterias</strong>, <code>Profesor</code> puede no ser una clave única por sí misma debido a que un profesor puede enseñar más de una materia, pero el par <code>(Profesor, Materia)</code> sí lo es. Esta tabla muestra claramente la relación entre profesores y materias, cumpliendo con la definición de BCNF porque cada atributo a la izquierda de una dependencia funcional es una superclave.</p>
<p>En la <strong>Tabla AsignacionesAula Actualizada</strong>, ya no mantenemos la <code>Materia</code> directamente, eliminando la dependencia funcional problemática. La relación entre un aula y quién la ocupa se mantiene, y si necesitamos encontrar qué materia se enseña en un aula, podemos hacer un JOIN con la <strong>Tabla ProfesoresMaterias</strong>.</p>
<p>Este ejemplo ilustra cómo aplicar BCNF para resolver problemas de dependencias funcionales no triviales que involucran claves candidatas, mejorando la integridad y la eficiencia del diseño de la base de datos.</p>
<h3 id="ejemplo-de-una-tabla-en-la-cuarta-forma-normal-4nf">Ejemplo de una tabla en la Cuarta Forma Normal (4NF)</h3>
<p>La Cuarta Forma Normal (4NF) aborda las relaciones multivaluadas independientes dentro de una base de datos. Una tabla se considera que está en 4NF si, y solo si, está en la Tercera Forma Normal (3NF) o en la Forma Normal de Boyce-Codd (BCNF) y no contiene ninguna forma de dependencias multivaluadas no triviales, a menos que sea respecto a una superclave. Esto significa que, para cada una de sus dependencias multivaluadas, cada conjunto de datos debe ser independiente de los otros conjuntos.</p>
<p>Para entender mejor, vamos a considerar un ejemplo que no cumple con 4NF y cómo transformarlo para que sí cumpla.</p>
<h3 id="ejemplo-antes-de-4nf">Ejemplo antes de 4NF</h3>
<p>Supongamos que tenemos una tabla de una conferencia académica. Esta tabla registra qué conferenciantes participarán y los temas en los que son expertos. Además, registra en qué idiomas pueden presentar, dado que la conferencia es internacional y algunos conferenciantes pueden presentar en múltiples idiomas.</p>
<p><strong>Tabla Conferenciantes (No en 4NF debido a dependencias multivaluadas)</strong></p>
<table>
<thead>
<tr>
<th>Conferenciante</th>
<th>Tema</th>
<th>Idioma</th>
</tr>
</thead>
<tbody>
<tr>
<td>Ana Gómez</td>
<td>Matemáticas</td>
<td>Español</td>
</tr>
<tr>
<td>Ana Gómez</td>
<td>Matemáticas</td>
<td>Inglés</td>
</tr>
<tr>
<td>Luis Pérez</td>
<td>Historia</td>
<td>Español</td>
</tr>
<tr>
<td>Juan Martínez</td>
<td>Inteligencia Artificial</td>
<td>Español</td>
</tr>
<tr>
<td>Juan Martínez</td>
<td>Inteligencia Artificial</td>
<td>Inglés</td>
</tr>
<tr>
<td>Juan Martínez</td>
<td>Inteligencia Artificial</td>
<td>Francés</td>
</tr>
</tbody>
</table>
<p>En esta tabla, Ana Gómez puede presentar &quot;Matemáticas&quot; tanto en &quot;Español&quot; como en &quot;Inglés&quot;, lo que representa una dependencia multivaluada entre <code>Conferenciante</code>, <code>Tema</code> y <code>Idioma</code>. Esto significa que los idiomas en los que puede presentar un conferenciante no dependen de los temas de los que habla, y viceversa, lo cual es una violación de 4NF.</p>
<h3 id="transformaci%C3%B3n-a-4nf">Transformación a 4NF</h3>
<p>Para corregir esta situación y llevar la tabla a 4NF, debemos dividir la tabla original en dos tablas, de manera que las dependencias multivaluadas se separen en tablas diferentes y cada una describa una relación independiente.</p>
<p><strong>Tabla TemasConferenciantes</strong></p>
<table>
<thead>
<tr>
<th>Conferenciante</th>
<th>Tema</th>
</tr>
</thead>
<tbody>
<tr>
<td>Ana Gómez</td>
<td>Matemáticas</td>
</tr>
<tr>
<td>Luis Pérez</td>
<td>Historia</td>
</tr>
<tr>
<td>Juan Martínez</td>
<td>Inteligencia Artificial</td>
</tr>
</tbody>
</table>
<p><strong>Tabla IdiomasConferenciantes</strong></p>
<table>
<thead>
<tr>
<th>Conferenciante</th>
<th>Idioma</th>
</tr>
</thead>
<tbody>
<tr>
<td>Ana Gómez</td>
<td>Español</td>
</tr>
<tr>
<td>Ana Gómez</td>
<td>Inglés</td>
</tr>
<tr>
<td>Luis Pérez</td>
<td>Español</td>
</tr>
<tr>
<td>Juan Martínez</td>
<td>Español</td>
</tr>
<tr>
<td>Juan Martínez</td>
<td>Inglés</td>
</tr>
<tr>
<td>Juan Martínez</td>
<td>Francés</td>
</tr>
</tbody>
</table>
<p>Con esta división:</p>
<ul>
<li>La <strong>Tabla TemasConferenciantes</strong> se enfoca exclusivamente en la relación entre conferenciantes y los temas de los que son expertos, sin considerar el idioma.</li>
<li>La <strong>Tabla IdiomasConferenciantes</strong> se enfoca en los idiomas que cada conferenciante puede usar para presentar, independientemente del tema.</li>
</ul>
<p>Esto asegura que cada tabla cumpla con 4NF al eliminar dependencias multivaluadas no triviales que no sean sobre una superclave. Ahora, la información está organizada de manera que cada relación multivaluada se maneja por separado, lo que simplifica la gestión de los datos y previene anomalías.</p>
<h3 id="ejercicios-para-determinar-si-se-cumple-o-no-la-forma-normal">Ejercicios para determinar si se cumple o no la Forma Normal</h3>
<p>Claro, aquí tienes una lista de ejercicios de opción múltiple enfocados en determinar si ciertas estructuras de tablas cumplen con las normas de normalización 1NF, 2NF, 3NF, BCNF, y 4NF. Cada pregunta incluye una breve descripción de una tabla y opciones para elegir qué forma normal cumple.</p>
<h3 id="ejercicio-1-1nf">Ejercicio 1: 1NF</h3>
<p><strong>Tabla Estudiantes</strong></p>
<table>
<thead>
<tr>
<th>ID_Estudiante</th>
<th>Nombre</th>
<th>Apellidos</th>
<th>Cursos</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>Ana</td>
<td>Gómez Ruiz</td>
<td>Matemáticas, Física</td>
</tr>
<tr>
<td>2</td>
<td>Luis</td>
<td>Pérez López</td>
<td>Literatura</td>
</tr>
<tr>
<td>3</td>
<td>Marta</td>
<td>Sánchez Molina</td>
<td>Biología, Química, Arte</td>
</tr>
</tbody>
</table>
<p>¿Esta tabla cumple con la Primera Forma Normal (1NF)?</p>
<p>a) Sí</p>
<p>b) No</p>
<hr>
<h3 id="ejercicio-2-2nf">Ejercicio 2: 2NF</h3>
<p><strong>Tabla Asignaciones</strong></p>
<table>
<thead>
<tr>
<th>ID_Asignación (PK)</th>
<th>ID_Profesor</th>
<th>NombreProfesor</th>
<th>ID_Curso</th>
<th>NombreCurso</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>P01</td>
<td>Ana Gómez</td>
<td>C01</td>
<td>Matemáticas</td>
</tr>
<tr>
<td>2</td>
<td>P02</td>
<td>Luis Pérez</td>
<td>C02</td>
<td>Física</td>
</tr>
</tbody>
</table>
<p>Suponiendo que cada <code>ID_Profesor</code> siempre tiene el mismo <code>NombreProfesor</code>, y cada <code>ID_Curso</code> siempre tiene el mismo <code>NombreCurso</code>, ¿esta tabla cumple con la Segunda Forma Normal (2NF)?</p>
<p>a) Sí</p>
<p>b) No</p>
<hr>
<h3 id="ejercicio-3-3nf">Ejercicio 3: 3NF</h3>
<p><strong>Tabla Empleados</strong></p>
<table>
<thead>
<tr>
<th>ID_Empleado (PK)</th>
<th>NombreEmpleado</th>
<th>ID_Departamento</th>
<th>NombreDepartamento</th>
<th>UbicaciónDepartamento</th>
</tr>
</thead>
<tbody>
<tr>
<td>E01</td>
<td>Juan Martínez</td>
<td>D01</td>
<td>Contabilidad</td>
<td>Edificio A</td>
</tr>
<tr>
<td>E02</td>
<td>Ana Gómez</td>
<td>D02</td>
<td>Marketing</td>
<td>Edificio B</td>
</tr>
</tbody>
</table>
<p>Dada la relación de que un departamento siempre está en la misma ubicación, ¿esta tabla cumple con la Tercera Forma Normal (3NF)?</p>
<p>a) Sí</p>
<p>b) No</p>
<hr>
<h3 id="ejercicio-4-bcnf">Ejercicio 4: BCNF</h3>
<p><strong>Tabla Clases</strong></p>
<table>
<thead>
<tr>
<th>ID_Clase (PK)</th>
<th>ID_Profesor</th>
<th>ID_Materia</th>
<th>Horario</th>
</tr>
</thead>
<tbody>
<tr>
<td>C01</td>
<td>P01</td>
<td>M01</td>
<td>Mañana</td>
</tr>
<tr>
<td>C02</td>
<td>P02</td>
<td>M02</td>
<td>Tarde</td>
</tr>
</tbody>
</table>
<p>Si <code>ID_Profesor</code> y <code>ID_Materia</code> pueden determinar de manera única <code>ID_Clase</code>, pero <code>ID_Clase</code> es la única clave primaria, ¿esta tabla cumple con la Forma Normal de Boyce-Codd (BCNF)?</p>
<p>a) Sí</p>
<p>b) No</p>
<hr>
<h3 id="ejercicio-5-4nf">Ejercicio 5: 4NF</h3>
<p><strong>Tabla Investigaciones</strong></p>
<table>
<thead>
<tr>
<th>ID_Investigador</th>
<th>CampoEstudio</th>
<th>Financiador</th>
</tr>
</thead>
<tbody>
<tr>
<td>INV01</td>
<td>Biología</td>
<td>Gobierno</td>
</tr>
<tr>
<td>INV01</td>
<td>Biología</td>
<td>Industria Privada</td>
</tr>
<tr>
<td>INV02</td>
<td>Física Cuántica</td>
<td>Gobierno</td>
</tr>
</tbody>
</table>
<p>Dado que un investigador puede trabajar en varios campos de estudio y puede ser financiado por diferentes entidades independientemente del campo de estudio, ¿esta tabla cumple con la Cuarta Forma Normal (4NF)?</p>
<p>a) Sí</p>
<p>b) No</p>
<hr>
<h3 id="respuesta-de-los-ejercicios">Respuesta de los ejercicios</h3>
<p><strong>Ejercicio 1. Respuesta Correcta:</strong> b) No (El campo <code>Cursos</code> no es atómico.)</p>
<p><strong>Ejercicio 2. Respuesta Correcta:</strong> b) No (Hay dependencias parciales; <code>NombreProfesor</code> depende solo de <code>ID_Profesor</code>, y <code>NombreCurso</code> depende solo de <code>ID_Curso</code>.)</p>
<p><strong>Ejercicio 3. Respuesta Correcta:</strong> b) No (Hay una dependencia transitoria; <code>UbicaciónDepartamento</code> depende de <code>ID_Departamento</code>, que no es la clave primaria.)</p>
<p><strong>Ejercicio 4. Respuesta Correcta:</strong> a) Sí (Todos los determinantes son superclaves.)</p>
<p><strong>Ejercicio 5. Respuesta Correcta:</strong> b) No (Hay una dependencia multivaluada entre <code>CampoEstudio</code> y <code>Financiador</code> respecto a <code>ID_Investigador</code>.)</p>
<h2 id="302-dise%C3%B1o-de-esquemas-avanzados">302. Diseño de esquemas avanzados</h2>
<p>El diseño de esquemas avanzados en bases de datos es un tema complejo que abarca la creación de estructuras de datos sofisticadas para soportar aplicaciones empresariales, científicas, o de cualquier índole que requiera un manejo eficiente y seguro de grandes volúmenes de información. Este proceso implica no solo la normalización para garantizar la integridad de los datos, sino también consideraciones sobre el rendimiento, la escalabilidad, la seguridad, y la capacidad de adaptación a cambios en los requisitos. A continuación, se describen algunos aspectos clave del diseño de esquemas avanzados:</p>
<h3 id="dise%C3%B1o-conceptual">Diseño Conceptual</h3>
<ul>
<li><strong>Modelado de Datos:</strong> Utiliza modelos conceptuales, como el modelo entidad-relación (ER) o el modelo de clases en UML, para representar de manera abstracta los datos y sus interrelaciones. Este paso es crucial para entender el dominio del problema y planificar la estructura de la base de datos.</li>
<li><strong>Identificación de Entidades y Relaciones:</strong> Define claramente las entidades (objetos de datos) y las relaciones entre estas entidades. Esto incluye especificar claves primarias y extranjeras, atributos, y las cardinalidades de las relaciones.</li>
</ul>
<h3 id="dise%C3%B1o-l%C3%B3gico">Diseño Lógico</h3>
<ul>
<li><strong>Normalización:</strong> Aplica técnicas de normalización hasta alcanzar, al menos, la Tercera Forma Normal (3NF) o la Forma Normal de Boyce-Codd (BCNF) para eliminar redundancias y dependencias innecesarias, garantizando así la integridad de los datos.</li>
<li><strong>Esquemas de Indexación y Particionamiento:</strong> Diseña índices para mejorar el rendimiento de las consultas y estrategias de particionamiento para distribuir los datos de manera eficiente entre varios discos o nodos en un sistema distribuido.</li>
</ul>
<h3 id="dise%C3%B1o-f%C3%ADsico">Diseño Físico</h3>
<ul>
<li><strong>Selección de Tipos de Datos:</strong> Escoge los tipos de datos más apropiados y eficientes para cada atributo, considerando el tipo de operaciones que se realizarán sobre estos datos.</li>
<li><strong>Almacenamiento de Datos:</strong> Define la estructura de almacenamiento, como la organización de archivos y métodos de acceso, optimizando el uso del espacio en disco y el tiempo de acceso.</li>
</ul>
<h3 id="optimizaci%C3%B3n-de-consultas">Optimización de Consultas</h3>
<ul>
<li><strong>Estrategias de Acceso:</strong> Implementa técnicas para optimizar las consultas, como la selección de algoritmos de join eficientes, el uso de vistas materializadas, y el caching de consultas frecuentes.</li>
<li><strong>Análisis de Rendimiento:</strong> Utiliza herramientas de análisis de rendimiento y ajusta el diseño del esquema basándose en los resultados para mejorar la velocidad de las operaciones de lectura y escritura.</li>
</ul>
<h3 id="consideraciones-de-escalabilidad-y-seguridad">Consideraciones de Escalabilidad y Seguridad</h3>
<ul>
<li><strong>Esquemas Distribuidos:</strong> Planifica esquemas que soporten la distribución de datos en un entorno distribuido, facilitando la escalabilidad horizontal.</li>
<li><strong>Control de Acceso:</strong> Define políticas de seguridad y mecanismos de control de acceso para proteger los datos contra accesos no autorizados.</li>
</ul>
<h3 id="dise%C3%B1o-para-aplicaciones-espec%C3%ADficas">Diseño para Aplicaciones Específicas</h3>
<ul>
<li><strong>Diseño para Big Data:</strong> Adapta el esquema para manejar volúmenes masivos de datos, considerando tecnologías como NoSQL o sistemas de almacenamiento de datos distribuidos.</li>
<li><strong>Diseño para Aplicaciones en Tiempo Real:</strong> Considera los requisitos de latencia baja y procesamiento en tiempo real, utilizando bases de datos en memoria y optimizando el esquema para actualizaciones rápidas y accesos de lectura.</li>
</ul>
<p>El diseño de esquemas avanzados es un proceso iterativo que requiere una comprensión profunda tanto del dominio de la aplicación como de las capacidades y limitaciones de la tecnología de bases de datos utilizada. La flexibilidad para adaptarse a cambios en los requisitos y el entorno tecnológico es crucial, al igual que la capacidad para prever y planificar el crecimiento futuro de la base de datos.</p>
<h3 id="caso-de-aplicaci%C3%B3n">Caso de Aplicación</h3>
<p>Vamos a diseñar un esquema avanzado para un sistema de gestión de bibliotecas que maneje libros, usuarios, préstamos y reservas. Este ejemplo ilustrará cómo se aplican algunos de los principios del diseño de esquemas avanzados para abordar requisitos complejos y garantizar la eficiencia, escalabilidad y seguridad.</p>
<h3 id="paso-1-dise%C3%B1o-conceptual">Paso 1: Diseño Conceptual</h3>
<p><strong>Entidades Principales:</strong></p>
<ol>
<li><strong>Libros:</strong> Cada libro tiene un identificador único, título, autores, ISBN, y categorías.</li>
<li><strong>Usuarios:</strong> Los usuarios están identificados por un ID único, y tienen nombres, correos electrónicos y roles (por ejemplo, estudiante, profesor).</li>
<li><strong>Préstamos:</strong> Representan la acción de prestar un libro a un usuario, con fechas de préstamo y devolución.</li>
<li><strong>Reservas:</strong> Permiten a los usuarios reservar libros que están actualmente prestados.</li>
</ol>
<p><strong>Relaciones:</strong></p>
<ul>
<li>Un usuario puede tener múltiples préstamos y reservas, pero cada préstamo o reserva se asocia a un solo usuario.</li>
<li>Un libro puede estar en múltiples préstamos o reservas a lo largo del tiempo, pero en un momento dado, está asociado a lo más un préstamo o reserva.</li>
</ul>
<h3 id="paso-2-dise%C3%B1o-l%C3%B3gico">Paso 2: Diseño Lógico</h3>
<p><strong>Tablas y sus relaciones:</strong></p>
<ol>
<li>
<p><strong>Tabla Libros</strong></p>
<ul>
<li>LibroID (PK)</li>
<li>Título</li>
<li>ISBN</li>
<li>Autores (podría normalizarse más si los autores se repiten a través de libros)</li>
<li>Categorías (normalizada en una tabla relacionada si un libro puede tener múltiples categorías)</li>
</ul>
</li>
<li>
<p><strong>Tabla Usuarios</strong></p>
<ul>
<li>UsuarioID (PK)</li>
<li>Nombre</li>
<li>CorreoElectrónico</li>
<li>Rol</li>
</ul>
</li>
<li>
<p><strong>Tabla Préstamos</strong></p>
<ul>
<li>PréstamoID (PK)</li>
<li>LibroID (FK)</li>
<li>UsuarioID (FK)</li>
<li>FechaPréstamo</li>
<li>FechaDevoluciónPrevista</li>
<li>FechaDevoluciónReal</li>
</ul>
</li>
<li>
<p><strong>Tabla Reservas</strong></p>
<ul>
<li>ReservaID (PK)</li>
<li>LibroID (FK)</li>
<li>UsuarioID (FK)</li>
<li>FechaReserva</li>
<li>Estado (activa, completada)</li>
</ul>
</li>
</ol>
<p><strong>Consideraciones:</strong></p>
<ul>
<li><strong>Normalización:</strong> Cada tabla está normalizada para reducir la redundancia. Los autores y categorías podrían requerir tablas separadas si se busca normalizar completamente.</li>
<li><strong>Índices:</strong> Crear índices en <code>LibroID</code> y <code>UsuarioID</code> en las tablas de préstamos y reservas para mejorar la eficiencia de las consultas.</li>
</ul>
<h3 id="paso-3-dise%C3%B1o-f%C3%ADsico">Paso 3: Diseño Físico</h3>
<ul>
<li><strong>Tipos de Datos:</strong> Escoger tipos de datos adecuados (por ejemplo, <code>VARCHAR</code> para nombres, <code>INT</code> para identificadores, <code>DATE</code> para las fechas).</li>
<li><strong>Métodos de Acceso:</strong> Utilizar índices B-tree para los campos frecuentemente buscados como <code>LibroID</code>, <code>UsuarioID</code>, <code>ISBN</code>.</li>
</ul>
<h3 id="paso-4-optimizaci%C3%B3n-de-consultas">Paso 4: Optimización de Consultas</h3>
<ul>
<li><strong>Vistas Materializadas:</strong> Para consultas frecuentes, como la disponibilidad actual de libros o el historial de préstamos de un usuario, se pueden crear vistas materializadas.</li>
<li><strong>Caching:</strong> Implementar caching de las consultas más frecuentes a nivel de aplicación.</li>
</ul>
<h3 id="paso-5-consideraciones-de-escalabilidad-y-seguridad">Paso 5: Consideraciones de Escalabilidad y Seguridad</h3>
<ul>
<li><strong>Escalabilidad:</strong> Diseñar la base de datos pensando en la escalabilidad horizontal, preparando las tablas para particionamiento si el volumen de datos crece significativamente.</li>
<li><strong>Seguridad:</strong> Implementar controles de acceso a nivel de base de datos, asegurando que solo los usuarios autorizados puedan modificar datos. Los roles de usuarios pueden ayudar a definir estos controles.</li>
</ul>
<h3 id="paso-6-dise%C3%B1o-para-aplicaciones-espec%C3%ADficas">Paso 6: Diseño para Aplicaciones Específicas</h3>
<ul>
<li><strong>Aplicación Web:</strong> Asegurar que el esquema sea compatible con consultas desde una aplicación web, optimizando para operaciones CRUD (crear, leer, actualizar, borrar) comunes en este tipo de interfaces.</li>
</ul>
<p>Este ejemplo muestra cómo el diseño de esquemas avanzados aborda los retos de manejar datos complejos y relacionados de manera eficiente y segura, preparando el sistema para un funcionamiento óptimo tanto en el presente como en el futuro.</p>
<h2 id="303-estrategias-de-particionamiento">303. Estrategias de particionamiento</h2>
<p>Las estrategias de particionamiento son técnicas fundamentales en la administración de bases de datos que buscan mejorar el rendimiento, la gestión, y la escalabilidad de las bases de datos, especialmente en sistemas de gran tamaño. El particionamiento implica dividir tablas grandes y sus índices en segmentos más pequeños y manejables, lo cual puede ayudar a optimizar las consultas, facilitar el mantenimiento y permitir una distribución más eficiente de los datos a través de múltiples discos o nodos en un sistema distribuido. A continuación, se describen varias estrategias de particionamiento comúnmente utilizadas:</p>
<h3 id="particionamiento-horizontal">Particionamiento Horizontal</h3>
<p>El particionamiento horizontal divide una tabla en múltiples tablas más pequeñas, donde cada tabla contiene un subconjunto de filas de la tabla original. Cada partición puede ser tratada como una tabla separada por el sistema de gestión de bases de datos (DBMS), pero desde la perspectiva del usuario, sigue siendo parte de la tabla original.</p>
<p><strong>Ejemplo:</strong> Particionar una tabla de transacciones por fecha, con cada partición conteniendo las transacciones de un año específico.</p>
<h3 id="particionamiento-vertical">Particionamiento Vertical</h3>
<p>El particionamiento vertical divide una tabla en varias tablas que contienen las mismas filas pero un subconjunto de columnas. Esto es útil para separar datos que son accedidos juntos frecuentemente de aquellos que no lo son, mejorando así el rendimiento de las lecturas.</p>
<p><strong>Ejemplo:</strong> En una tabla de usuarios, separar los datos de login (que se acceden frecuentemente) de la información personal detallada (que se accede menos).</p>
<h3 id="particionamiento-por-clave-de-partici%C3%B3n-partition-key">Particionamiento por Clave de Partición (Partition Key)</h3>
<p>Esta estrategia utiliza una columna específica o un conjunto de columnas para determinar cómo se dividirán los datos entre las particiones. Es común en bases de datos distribuidas donde la clave de partición puede ayudar a distribuir los datos de manera uniforme a través de los nodos.</p>
<p><strong>Ejemplo:</strong> Particionar una tabla de clientes usando el país como clave de partición, lo que coloca a todos los clientes del mismo país en la misma partición.</p>
<h3 id="particionamiento-por-rango">Particionamiento por Rango</h3>
<p>El particionamiento por rango involucra dividir datos basados en rangos de valores para una columna específica. Esta estrategia es ideal para datos con un orden inherente.</p>
<p><strong>Ejemplo:</strong> Particionar una tabla de registros financieros por rango de fechas, con cada partición almacenando los registros de un trimestre específico.</p>
<h3 id="particionamiento-por-lista">Particionamiento por Lista</h3>
<p>Similar al particionamiento por rango, pero en lugar de rangos de valores, se utilizan listas de valores específicos para dividir los datos.</p>
<p><strong>Ejemplo:</strong> Particionar una tabla de empleados basada en el departamento, donde cada partición corresponde a un departamento específico.</p>
<h3 id="particionamiento-compuesto">Particionamiento Compuesto</h3>
<p>Combina dos o más estrategias de particionamiento para crear particiones más específicas y optimizadas. Por ejemplo, se podría primero aplicar un particionamiento horizontal y luego un particionamiento vertical sobre el resultado.</p>
<p><strong>Ejemplo:</strong> Particionar una tabla de eventos primero por año (horizontal) y luego, dentro de cada año, particionar por tipo de evento (vertical).</p>
<h3 id="consideraciones">Consideraciones</h3>
<ul>
<li><strong>Rendimiento:</strong> El particionamiento puede mejorar significativamente el rendimiento de las consultas si las particiones están diseñadas de acuerdo con los patrones de acceso a los datos.</li>
<li><strong>Mantenimiento:</strong> Las particiones facilitan tareas de mantenimiento como la reconstrucción de índices o las copias de seguridad, ya que estas operaciones pueden realizarse en particiones individuales.</li>
<li><strong>Escalabilidad:</strong> El particionamiento es clave para la escalabilidad, especialmente en sistemas distribuidos, ya que permite distribuir la carga de manera más eficiente.</li>
</ul>
<p>Elegir la estrategia de particionamiento adecuada depende en gran medida del modelo de datos específico, los patrones de acceso a los datos y los objetivos de rendimiento.</p>
<h3 id="ejemplo-de-una-partici%C3%B3n-horizontal">Ejemplo de una Partición Horizontal</h3>
<p>Vamos a profundizar con un ejemplo práctico de particionamiento horizontal utilizando una base de datos de un sistema de gestión de pedidos en línea. Imagina que la tabla <code>Pedidos</code> ha crecido considerablemente debido al aumento del volumen de transacciones. Para mejorar el rendimiento y la gestión de esta tabla, decidimos implementar un particionamiento horizontal.</p>
<h3 id="situaci%C3%B3n-inicial">Situación Inicial</h3>
<p><strong>Tabla <code>Pedidos</code> (Antes del Particionamiento):</strong></p>
<table>
<thead>
<tr>
<th>PedidoID</th>
<th>ClienteID</th>
<th>FechaPedido</th>
<th>Total</th>
<th>Estado</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>101</td>
<td>2023-01-05</td>
<td>100.00</td>
<td>Enviado</td>
</tr>
<tr>
<td>2</td>
<td>102</td>
<td>2023-03-12</td>
<td>150.00</td>
<td>Pendiente</td>
</tr>
<tr>
<td>3</td>
<td>103</td>
<td>2023-04-15</td>
<td>200.00</td>
<td>Entregado</td>
</tr>
<tr>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
</tr>
<tr>
<td>N</td>
<td>XYZ</td>
<td>2023-12-30</td>
<td>250.00</td>
<td>Cancelado</td>
</tr>
</tbody>
</table>
<p>Con miles o millones de filas, las operaciones en esta tabla se vuelven lentas, especialmente las consultas, actualizaciones y el mantenimiento de índices.</p>
<h3 id="implementaci%C3%B3n-del-particionamiento-horizontal">Implementación del Particionamiento Horizontal</h3>
<p>Decidimos particionar la tabla <code>Pedidos</code> por el <code>Estado</code> del pedido, ya que las consultas a la base de datos a menudo requieren filtrar por este campo. Esto divide la tabla original en varias tablas más pequeñas, cada una conteniendo pedidos con el mismo estado.</p>
<p><strong>Tablas Particionadas:</strong></p>
<ol>
<li><strong>Pedidos_Enviado</strong></li>
<li><strong>Pedidos_Pendiente</strong></li>
<li><strong>Pedidos_Entregado</strong></li>
<li><strong>Pedidos_Cancelado</strong></li>
</ol>
<p>Cada tabla tiene la misma estructura que la tabla <code>Pedidos</code> original, pero contiene solo las filas correspondientes a su respectivo estado de pedido.</p>
<h3 id="ejemplo-de-tabla-particionada-pedidosenviado">Ejemplo de Tabla Particionada: <code>Pedidos_Enviado</code></h3>
<table>
<thead>
<tr>
<th>PedidoID</th>
<th>ClienteID</th>
<th>FechaPedido</th>
<th>Total</th>
<th>Estado</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>101</td>
<td>2023-01-05</td>
<td>100.00</td>
<td>Enviado</td>
</tr>
</tbody>
</table>
<h3 id="beneficios">Beneficios</h3>
<ul>
<li><strong>Mejora del Rendimiento:</strong> Las consultas que filtran por <code>Estado</code> se vuelven más rápidas, ya que cada consulta necesita buscar en una tabla más pequeña.</li>
<li><strong>Mantenimiento Más Fácil:</strong> Operaciones como la reconstrucción de índices, copias de seguridad, y purgas (eliminación de datos antiguos) se pueden realizar más eficientemente, ya que pueden enfocarse en tablas específicas basadas en criterios de negocio.</li>
<li><strong>Escalabilidad:</strong> El particionamiento facilita la distribución de las cargas de trabajo a través de múltiples discos o servidores, si cada partición se almacena separadamente.</li>
</ul>
<h3 id="consideraciones">Consideraciones</h3>
<ul>
<li><strong>Diseño de Consultas:</strong> Las consultas que no filtran por <code>Estado</code> podrían necesitar acceder a múltiples tablas particionadas y, por lo tanto, pueden requerir un diseño cuidadoso para mantener el rendimiento.</li>
<li><strong>Gestión de Transacciones:</strong> Las operaciones que involucran múltiples estados (por ejemplo, cambiar un pedido de <code>Pendiente</code> a <code>Enviado</code>) pueden necesitar manejo especial para asegurar la consistencia a través de las particiones.</li>
</ul>
<p>Este ejemplo ilustra cómo el particionamiento horizontal puede ser utilizado para optimizar el rendimiento y la gestión de las bases de datos, especialmente en escenarios donde el volumen de datos es grande y hay patrones claros de acceso a los datos.</p>
<h3 id="ejemplo-de-una-tabla-particionada-por-lista">Ejemplo de una Tabla Particionada por Lista</h3>
<p>El particionamiento de tablas es una funcionalidad avanzada que permite dividir tablas y sus índices en unidades más pequeñas y manejables, facilitando el manejo de grandes volúmenes de datos y mejorando el rendimiento de las consultas. Para el caso de la tabla <code>Pedidos</code> particionada por el campo <code>Estado</code>.</p>
<p>Oracle soporta varios tipos de particionamiento, pero para este ejemplo, utilizaremos el particionamiento por lista, que es adecuado para dividir los datos en base a un conjunto discreto de valores, como los estados de un pedido.</p>
<h3 id="creaci%C3%B3n-de-la-tabla-particionada-por-lista">Creación de la Tabla Particionada por Lista</h3>
<pre class="hljs"><code><div><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> Pedidos (
    PedidoID NUMBER <span class="hljs-keyword">PRIMARY</span> KEY,
    ClienteID NUMBER,
    FechaPedido <span class="hljs-type">DATE</span>,
    Total NUMBER(<span class="hljs-number">10</span>,<span class="hljs-number">2</span>),
    Estado VARCHAR2(<span class="hljs-number">50</span>)
)
<span class="hljs-keyword">PARTITION</span> <span class="hljs-keyword">BY</span> LIST (Estado) (
    <span class="hljs-keyword">PARTITION</span> Pedidos_Enviado <span class="hljs-keyword">VALUES</span> (<span class="hljs-string">&#x27;Enviado&#x27;</span>),
    <span class="hljs-keyword">PARTITION</span> Pedidos_Pendiente <span class="hljs-keyword">VALUES</span> (<span class="hljs-string">&#x27;Pendiente&#x27;</span>),
    <span class="hljs-keyword">PARTITION</span> Pedidos_Entregado <span class="hljs-keyword">VALUES</span> (<span class="hljs-string">&#x27;Entregado&#x27;</span>),
    <span class="hljs-keyword">PARTITION</span> Pedidos_Cancelado <span class="hljs-keyword">VALUES</span> (<span class="hljs-string">&#x27;Cancelado&#x27;</span>)
);
</div></code></pre>
<h3 id="explicaci%C3%B3n">Explicación:</h3>
<ul>
<li><code>CREATE TABLE Pedidos (...)</code>: Define la estructura de la tabla <code>Pedidos</code>.</li>
<li><code>PARTITION BY LIST (Estado) (...)</code>: Especifica que el particionamiento se realizará por lista basándose en el campo <code>Estado</code>.</li>
<li>Dentro de los paréntesis de <code>PARTITION BY LIST</code>, se definen las particiones individuales para cada valor del campo <code>Estado</code>. Cada partición se nombra (<code>Pedidos_Enviado</code>, <code>Pedidos_Pendiente</code>, etc.) y se asigna a un valor específico del campo <code>Estado</code>.</li>
</ul>
<h3 id="consideraciones-adicionales">Consideraciones Adicionales:</h3>
<ul>
<li><strong>Almacenamiento:</strong> Oracle permite especificar opciones de almacenamiento para cada partición, lo que puede ser útil para optimizar el rendimiento según el acceso a los datos.</li>
<li><strong>Índices Particionados:</strong> También puedes crear índices particionados para mejorar el rendimiento de las consultas. Los índices pueden particionarse de manera similar a las tablas.</li>
<li><strong>Mantenimiento de Particiones:</strong> Oracle proporciona una amplia gama de operaciones de mantenimiento de particiones, como agregar nuevas particiones, fusionar particiones existentes, dividir particiones y eliminar particiones.</li>
</ul>
<p>Este ejemplo muestra cómo crear una tabla particionada por lista, lo que puede mejorar significativamente el rendimiento de las consultas y la eficiencia del mantenimiento para tablas grandes al segmentar los datos en particiones más pequeñas y manejables.</p>
<h3 id="ejemplo-de-una-tabla-particionada-por-rango-de-fechas">Ejemplo de una Tabla Particionada por Rango de Fechas</h3>
<p>Crear una tabla particionada por rango de fechas en Oracle es una práctica común para manejar datos históricos o datos que crecen con el tiempo, como registros de transacciones o logs de eventos. Este método facilita el manejo de grandes volúmenes de datos segmentándolos en particiones basadas en rangos de fechas específicos, lo cual puede mejorar el rendimiento de las consultas y simplificar las operaciones de mantenimiento. A continuación, se muestra cómo crear una tabla particionada por rango de fechas en Oracle.</p>
<h3 id="ejemplo-creaci%C3%B3n-de-una-tabla-de-transacciones-particionada-por-rango-de-fechas">Ejemplo: Creación de una Tabla de Transacciones Particionada por Rango de Fechas</h3>
<p>Supongamos que queremos crear una tabla <code>Transacciones</code> que contenga registros de transacciones financieras, y queremos particionar esta tabla por mes, para los años específicos que se esperan tener transacciones.</p>
<pre class="hljs"><code><div><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> Transacciones (
    TransaccionID NUMBER <span class="hljs-keyword">PRIMARY</span> KEY,
    FechaTransaccion <span class="hljs-type">DATE</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,
    ClienteID NUMBER,
    Monto NUMBER(<span class="hljs-number">10</span>,<span class="hljs-number">2</span>),
    Detalle VARCHAR2(<span class="hljs-number">255</span>)
)
<span class="hljs-keyword">PARTITION</span> <span class="hljs-keyword">BY</span> <span class="hljs-keyword">RANGE</span> (FechaTransaccion) (
    <span class="hljs-keyword">PARTITION</span> transacciones_2023_q1 <span class="hljs-keyword">VALUES</span> LESS THAN (TO_DATE(<span class="hljs-string">&#x27;2023-04-01&#x27;</span>, <span class="hljs-string">&#x27;YYYY-MM-DD&#x27;</span>)),
    <span class="hljs-keyword">PARTITION</span> transacciones_2023_q2 <span class="hljs-keyword">VALUES</span> LESS THAN (TO_DATE(<span class="hljs-string">&#x27;2023-07-01&#x27;</span>, <span class="hljs-string">&#x27;YYYY-MM-DD&#x27;</span>)),
    <span class="hljs-keyword">PARTITION</span> transacciones_2023_q3 <span class="hljs-keyword">VALUES</span> LESS THAN (TO_DATE(<span class="hljs-string">&#x27;2023-10-01&#x27;</span>, <span class="hljs-string">&#x27;YYYY-MM-DD&#x27;</span>)),
    <span class="hljs-keyword">PARTITION</span> transacciones_2023_q4 <span class="hljs-keyword">VALUES</span> LESS THAN (TO_DATE(<span class="hljs-string">&#x27;2024-01-01&#x27;</span>, <span class="hljs-string">&#x27;YYYY-MM-DD&#x27;</span>)),
    <span class="hljs-keyword">PARTITION</span> transacciones_2024_q1 <span class="hljs-keyword">VALUES</span> LESS THAN (TO_DATE(<span class="hljs-string">&#x27;2024-04-01&#x27;</span>, <span class="hljs-string">&#x27;YYYY-MM-DD&#x27;</span>))
    <span class="hljs-comment">-- Más particiones pueden ser añadidas según sea necesario.</span>
);
</div></code></pre>
<h3 id="explicaci%C3%B3n">Explicación:</h3>
<ul>
<li><code>CREATE TABLE Transacciones (...)</code>: Define la estructura de la tabla <code>Transacciones</code>.</li>
<li><code>PARTITION BY RANGE (FechaTransaccion) (...)</code>: Especifica que el particionamiento se realizará por rango, basado en la columna <code>FechaTransaccion</code>.</li>
<li><code>PARTITION transacciones_2023_q1 VALUES LESS THAN (...)</code>: Crea una partición para las transacciones del primer trimestre de 2023, indicando que esta partición contendrá todas las transacciones con una <code>FechaTransaccion</code> menor que el 1 de abril de 2023. Se siguen patrones similares para los trimestres restantes y años futuros.</li>
</ul>
<h3 id="consideraciones-adicionales">Consideraciones Adicionales:</h3>
<ul>
<li><strong>Flexibilidad:</strong> Oracle permite modificar el esquema de particionamiento después de la creación, agregando, fusionando, dividiendo o eliminando particiones según cambien los requisitos de almacenamiento de datos.</li>
<li><strong>Índices Particionados Localmente:</strong> Los índices en tablas particionadas pueden ser localmente particionados, es decir, cada partición de la tabla tiene su propia partición correspondiente en el índice, lo que puede mejorar el rendimiento de las consultas.</li>
<li><strong>Operaciones de Mantenimiento Eficientes:</strong> Las particiones facilitan tareas de mantenimiento como copias de seguridad, purga de datos antiguos y optimización de almacenamiento, ya que estas operaciones pueden enfocarse en particiones específicas sin afectar el resto de la tabla.</li>
</ul>
<p>Este enfoque de particionamiento por rango de fechas es especialmente útil para gestionar datos que se acumulan con el tiempo, permitiendo un acceso más rápido a los segmentos de datos más relevantes y simplificando el mantenimiento de grandes volúmenes de información.</p>
<p>Las particiones deben ser excluyentes entre sí para evitar ambigüedades sobre dónde se almacenan los datos. Cada fila de datos solo puede pertenecer a una partición. En el contexto del particionamiento por rango, especialmente cuando se trata de fechas, esto significa que cada rango de fechas definido para una partición no debe solaparse con los rangos de las otras particiones. Oracle garantiza esto mediante el uso de la cláusula <code>VALUES LESS THAN</code>, asegurando que los límites superiores de una partición sean el límite inferior de la siguiente, sin superposiciones.</p>
<p>Por ejemplo, si tienes particiones definidas por trimestres para un año, se vería algo así:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">PARTITION</span> <span class="hljs-keyword">BY</span> <span class="hljs-keyword">RANGE</span> (FechaTransaccion) (
    <span class="hljs-keyword">PARTITION</span> q1 <span class="hljs-keyword">VALUES</span> LESS THAN (TO_DATE(<span class="hljs-string">&#x27;2023-04-01&#x27;</span>, <span class="hljs-string">&#x27;YYYY-MM-DD&#x27;</span>)),
    <span class="hljs-keyword">PARTITION</span> q2 <span class="hljs-keyword">VALUES</span> LESS THAN (TO_DATE(<span class="hljs-string">&#x27;2023-07-01&#x27;</span>, <span class="hljs-string">&#x27;YYYY-MM-DD&#x27;</span>)),
    <span class="hljs-keyword">PARTITION</span> q3 <span class="hljs-keyword">VALUES</span> LESS THAN (TO_DATE(<span class="hljs-string">&#x27;2023-10-01&#x27;</span>, <span class="hljs-string">&#x27;YYYY-MM-DD&#x27;</span>)),
    <span class="hljs-keyword">PARTITION</span> q4 <span class="hljs-keyword">VALUES</span> LESS THAN (TO_DATE(<span class="hljs-string">&#x27;2024-01-01&#x27;</span>, <span class="hljs-string">&#x27;YYYY-MM-DD&#x27;</span>))
);
</div></code></pre>
<p>En este caso:</p>
<ul>
<li>La partición <code>q1</code> captura todas las fechas desde el inicio de la tabla hasta el 31 de marzo de 2023.</li>
<li>La partición <code>q2</code> captura todas las fechas desde el 1 de abril de 2023 hasta el 30 de junio de 2023.</li>
<li>Y así sucesivamente, con cada partición capturando un rango único y no solapado de fechas.</li>
</ul>
<p>Estos rangos son excluyentes entre sí porque el límite superior de una partición es el límite inferior de la siguiente. Por lo tanto, cada transacción basada en su <code>FechaTransaccion</code> solo puede caer en una de estas particiones.</p>
<p>Si hay intentos de solapamiento en la definición de las particiones, Oracle rechazará la definición de la tabla particionada debido a errores de definición. La exclusividad de las particiones asegura la integridad y la lógica en la organización de los datos dentro de la base de datos.</p>
<h3 id="eliminar-una-partici%C3%B3n">Eliminar una Partición</h3>
<p>Eliminar datos de una partición específica puede ser una operación eficiente para gestionar el tamaño de la base de datos y mantener solo los datos relevantes. Las operaciones de eliminación pueden ejecutarse directamente sobre particiones individuales sin afectar las otras, lo que puede ser mucho más rápido que ejecutar un comando <code>DELETE</code> basado en criterios de selección que requieren escanear toda la tabla. Aquí te muestro cómo podrías hacerlo en Oracle, considerando tanto la eliminación de filas específicas como la eliminación (y opcionalmente el truncamiento) de toda una partición.</p>
<h3 id="eliminaci%C3%B3n-de-filas-espec%C3%ADficas-de-una-partici%C3%B3n">Eliminación de Filas Específicas de una Partición</h3>
<p>Para eliminar filas específicas de una partición basándote en ciertos criterios, usarías un comando <code>DELETE</code> estándar con una cláusula <code>WHERE</code> que especifique los criterios de las filas a eliminar. Oracle optimizará la operación al limitar la búsqueda a la partición relevante si los criterios de selección hacen uso de la columna de particionamiento. Por ejemplo:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> transacciones <span class="hljs-keyword">WHERE</span> FechaTransaccion <span class="hljs-keyword">BETWEEN</span> <span class="hljs-string">&#x27;2023-01-01&#x27;</span> <span class="hljs-keyword">AND</span> <span class="hljs-string">&#x27;2023-03-31&#x27;</span>;
</div></code></pre>
<p>Esta operación eliminaría filas de la partición correspondiente al primer trimestre de 2023, asumiendo que la tabla <code>transacciones</code> está particionada por la columna <code>FechaTransaccion</code> y que existe una partición que cubre este rango de fechas.</p>
<h3 id="truncamiento-de-una-partici%C3%B3n">Truncamiento de una Partición</h3>
<p>Si tu objetivo es eliminar todas las filas de una partición sin tocar las otras particiones, el truncamiento es una operación más eficiente que <code>DELETE</code>. Truncar una partición elimina todas sus filas de manera instantánea y libera el espacio ocupado, sin generar una gran cantidad de registros de redo (lo cual es beneficioso desde el punto de vista del rendimiento y la administración del espacio de almacenamiento).</p>
<pre class="hljs"><code><div><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> transacciones <span class="hljs-keyword">TRUNCATE</span> <span class="hljs-keyword">PARTITION</span> transacciones_2023_q1;
</div></code></pre>
<p>Este comando elimina todas las filas de la partición <code>transacciones_2023_q1</code> sin afectar otras particiones de la tabla <code>transacciones</code>.</p>
<h3 id="consideraciones">Consideraciones</h3>
<ul>
<li><strong>Impacto en el Rendimiento:</strong> El truncamiento de una partición es generalmente mucho más rápido que la eliminación de filas porque es una operación de metadatos. No tiene que escanear y marcar cada fila para eliminación.</li>
<li><strong>Recuperación de Espacio:</strong> El truncamiento libera el espacio ocupado por la partición, haciéndolo disponible para otros usos dentro de la base de datos.</li>
<li><strong>Irreversible:</strong> A diferencia de un <code>DELETE</code>, donde puedes usar transacciones para deshacer la operación antes de confirmar, el truncamiento es inmediato e irreversible una vez ejecutado.</li>
<li><strong>Restricciones de Integridad y Llaves Foráneas:</strong> Tanto para <code>DELETE</code> como para <code>TRUNCATE</code>, necesitas tener en cuenta las restricciones de integridad. El truncamiento de una partición puede fallar si hay restricciones de llave foránea que dependen de las filas de la partición.</li>
</ul>
<p>El uso adecuado de estas operaciones puede ayudar a mantener el tamaño de la base de datos controlado y asegurar que el rendimiento no decaiga debido a la presencia de grandes cantidades de datos históricos innecesarios.</p>
<h3 id="uso-de-particiones-en-las-consultas">Uso de Particiones en las consultas</h3>
<p>Oracle permite consultar particiones específicas utilizando la cláusula <code>PARTITION</code> en una consulta <code>SELECT</code>. Por ejemplo, si tienes una tabla <code>transacciones</code> particionada por trimestre y quieres consultar solo los datos de la partición correspondiente al primer trimestre de 2023, podrías usar:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> transacciones <span class="hljs-keyword">PARTITION</span> (transacciones_2023_q1);
</div></code></pre>
<p>Esta consulta accedería directamente a los datos en la partición <code>transacciones_2023_q1</code>, lo cual puede ser más eficiente que una consulta a toda la tabla, especialmente si la partición es significativamente más pequeña que la tabla completa.</p>
<h3 id="consideraciones">Consideraciones</h3>
<ul>
<li><strong>Rendimiento:</strong> Consultar una partición específica puede ser mucho más rápido que consultar toda la tabla, especialmente si la tabla es grande y la partición es relativamente pequeña. Sin embargo, es importante recordar que el optimizador de consultas de tu SGBD generalmente puede identificar cuándo una consulta solo afecta a una partición y optimizarla en consecuencia, incluso si consultas la tabla completa.</li>
<li><strong>Mantenibilidad:</strong> Aunque consultar particiones directamente puede ser útil, hacerlo regularmente en aplicaciones o scripts puede reducir la mantenibilidad de tu código. Si la estructura de particionamiento cambia (por ejemplo, si se agregan, fusionan o dividen particiones), cualquier consulta que acceda a particiones específicas por nombre necesitará actualizarse.</li>
<li><strong>Usabilidad:</strong> El acceso directo a las particiones puede no ser soportado o puede ser diferente en otros SGBD. Si tu aplicación necesita ser portátil entre diferentes sistemas de bases de datos, dependiendo de esta característica puede no ser ideal.</li>
</ul>
<p>En resumen, aunque técnicamente es posible y a veces útil consultar particiones directamente, es una práctica que debe usarse con consideración. Para la mayoría de las operaciones, es mejor confiar en el optimizador de consultas del SGBD para gestionar el acceso a los datos particionados de manera eficiente, a menos que haya una razón específica para enfocarse en una partición.</p>

</body>
</html>
